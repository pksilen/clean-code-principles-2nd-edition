# Coding Principles

This chapter presents principles for coding. The following principles are presented:

- Uniform variable naming principle
- Uniform source code repository structure principle
- Domain-based source code structure principle
- Avoid comments principle
- Function single return statement principle
- Prefer statically typed language principle
- Refactoring principle
- Static code analysis principle
- Error/Exception handling principle
- Avoid off-by-one errors principle
- Be critical when googling principle
- Make one change at a time principle
- Choosing right 3rd party component principle
- Use appropriate data structure principle
- Optimization principle

## Uniform Variable Naming Principle

> ***A good variable name should describe the variable's purpose and its type.***

Writing your code with great names, at best, makes it read like prose. And remember that code is more
often read than written, so code must be easy to read and understand.

Naming variables with names that convey information about the variable's type is crucial in untyped languages
and beneficial in typed languages because modern typed languages use automatic type deduction, and you won't always see the
actual variable type. But when the variable's name tells its type, it does not matter if the type name is not visible.

If a variable name is 20 or more characters long, consider making it shorter. Try to abbreviate
one or more words in the variable name, but only use meaningful and well-known abbreviations. If such abbreviations don't exist, then
don't abbreviate at all. For example, if you have a variable named `environmentVariableName`, you should try to shorten it because
it is over 20 characters long. You can abbreviate *environment* to *environ* and *variable* to *var*, resulting in a variable
name `environVarName` that is short enough. Both abbreviations `environ` and `var` are commonly used and well understood.
Let's have another example with a variable named `loyaltyBonusPercentage`. You cannot abbreviate *loyalty*. You cannot abbreviate
*bonus*. But you can abbreviate *percentage* to *percent* or even *pct*. I would rather use *percent* instead of *pct*. Using
*percent* makes the variable name shorter than 20 characters.

If a variable name is less than 20 characters long, you don't need to shorten it. If you have several variables named in
a similar wording and one or more of them needs abbreviating, you can use that abbreviation in all the variable names for
consistency. For example, if you have variables `configurationFile` and `configurationFilePparser`, you
can abbreviate the both to `configFile` and `configFileParser`.

In the following sections, naming conventions for different types of variables are proposed.

### Naming Integer Variables

Some variables are intrinsically integers, like *age* or *year*. Everybody immediately understands that the type of
an *age* or *year* variable is a number and, more specifically, an integer. So, you don't have to add anything to the variable's
name to indicate its type. It already tells you its type.

One of the most used categories of integer variables is a count or number of something. You see those kinds of variables in every piece
of code. I recommend using the following convention for naming those variables: *numberOf&lt;something&gt;* or alternatively
*&lt;something&gt;Count*. For example, *numberOfFailures* or *failureCount*. You should not use a variable named *failures*
to designate a failure count. The problem with that variable name is it does not clearly specify the variable type
and thus can cause some confusion. This is because a variable named *failures* can be misunderstood as a collection variable
(e.g., a list of failures).

If the unit of a variable is not self-evident, always add information about the unit to the end of the variable name. For example, instead of
naming a variable *tooltipShowDelay*, you should name it *tooltipShowDelayInMillis* or *tooltipShowDelayInMs*. If you have a variable
whose unit is self-evident, unit information is not needed. So, there is no need to name an *age* variable as *ageInYyears*. But if you are
measuring age in months, you must name the respective variable as *ageInMonths* so that people don't assume that age is measured in
years.

### Naming Floating-Point Number Variables

Floating-point numbers are not as common as integers, but sometimes you need them too. Some values are intrinsically floating-point numbers,
like most un-rounded measures (e.g., price, height, width, or weight). A floating-point variable would be a safe bet if you need to store a measured value.

If you need to store an amount of something that is not an integer, use a variable named *&lt;something&gt;Amount*, like *rainfallAmount*.
When you see the “amount of something” in code, you can automatically think it is a floating-point number. If you need to use a number in arithmetic,
depending on the application, you might want to use either floating-point or integer arithmetic. In the case of money, you should use
integer arithmetic to avoid rounding errors. Instead of a floating-point *moneyAmount* variable, you should have
an integer variable, like *moneyInCents*.

If the unit of a variable is not self-evident, add information about the unit to the end of the variable name, like *rainfallAmountInMm*, *widthInInches*,
*angleInDegrees* (values 0-360), *failurePercent* (values 0-100), or *failureRatio* (values 0-1).

### Naming Boolean Variables

Boolean variables can have only one of two values: true or false. The name of a boolean variable should form a statement where the answer is
true or false, or yes or no. Typical boolean variable naming patterns are: *is&lt;something&gt;*, *has&lt;something&gt;*, *did&lt;something&gt;*,
*should&lt;something&gt;*, *can&lt;something&gt;, or *will&lt;something&gt;*. Some examples of variable names following the above patterns are
*isDisabled*, *hasErrors*, *didUpdate*, *shouldUpdate*, and *willUpdate*.

The verb in the boolean variable name does not have to be at the beginning. It can and should be in the middle if it makes the code read better.
Boolean variables are often used in if-statements where changing the word order in the variable name can make the code read
better. Remember that, at best, code reads like beautiful prose and is read more often than written.

Below is a C++ code snippet where we have a boolean variable named `isPoolFull`:

```cpp
if (const bool isPoolFull = m_pooledMessages.size() >= 200U;
      isPoolFull)
{
  // ...
}
else
{
  // ...
}
```

We can change the variable name to `poolIsFfull` to make the if-statement read more fluently. In the below example, the if-statement
reads "if poolIsFull" instead of "if isPoolFull":

```cpp
if (const bool poolIsFull = m_pooledMessages.size() >= 200U;
      poolIsFull)
{
  // ...
```

Don't use boolean variable names in the form of *&lt;passive-verb&gt;Something*, like *insertedField*, because this can confuse the reader.
It is unclear if the variable name is a noun (a field that was inserted) that names an object or a boolean statement.
Instead, use either *didInsertField* or *fieldWasInserted*.

Below is a Go language example of the incorrect naming of a variable used to store a function return value. Someone might think
that `tablesDropped` means a list of dropped table names. So, the name of the variable is obscure and should be changed.

```go
tablesDropped := dropRedundantTables(prefix,
                                     vmsdata,
                                     cfg.HiveDatabase,
                                     hiveClient,
                                     logger)
if tablesDropped {
  // ...
}
```

Below is the above example modified so that the variable name is changed to indicate a boolean statement:

```go
tablesWereDropped := dropRedundantTables(prefix,
                                         vmsdata,
                                         cfg.HiveDatabase,
                                         hiveClient,
                                         logger)
if tablesWereDropped {
  // ...
}
```

You could have used a variable named `didDropTables`, but the `tablesWereDropped` makes the if-statement more readable.
If the return value of the `dropRedundantTables` function were a list of dropped table names, I would name the
return value receiving variable as `droppedTableNames`.

When you read code containing a negated boolean variable, it usually reads terrible, for example:

```java
final var appWasStarted = app.start();

if (!appWasStarted) {
  // ...
}
```

To improve the readability, you can mentally move the `not` word to the correct place to make the sentence
read like proper English. For example: *if appWas not Started*

The other option is to negate the variable. That is done by negating both sides of the assignment by adding
`not` on both sides of the assignment operator. Here is an example:

```java
final var appWasNotStarted = !app.start();

if (appWasNotStarted) {
  // ...
}
```

Below is a real-life example where a boolean property is named wrong:

```
sonar.buildBreaker.skip = true
```

The `skip` is not a correctly named boolean property. From the above statement, it is difficult to understand when a build is broken because no boolean statement that evaluates either true or false is made.
Let's refactor the statement:

```
sonar.shouldBreakBuildOnQualityGateFailure = true
```

### Naming String Variables

String variables are prevalent, and many things are intrinsically strings, like _name_, _title_, _city_, _country_, or _topic_.
When you need to store numerical data in a string variable, tell the code reader clearly that it is a question about a number in
string format, and use a variable name in the following format: _&lt;someValue&gt;String_ or _&lt;someValue&gt;AsString_. It makes
the code more prominent and easier to understand. For example in JavaScript:

```js
const year = parseInt(yearAsString, 10);
```

If you have a string variable that could be confused with an object variable, like `schema` (could be confused with an instance of `Schema` class), but it is a string,
add *string* to the end of the variable name, e.g., `schemaString`. Here is an example:

```java
final var schema = schemaParser.parse(schemaString);
```

### Naming Enum Variables

Name enum variables with the same name as the enum type. E.g., a `CarType` enum variable should be named `carType`.
If the name of an enum type is very generic, like `Result`, you might benefit from declaring an enum variable with some
detail added to the variable name. Below is an example of a very generic enum type name:

{title: "PulsarProducer.cpp"}
```cpp
// Returns enum type 'Result'
const auto result = pulsar::createProducer(...);

if (result == Result.Ok) {
  // ...
}
```

Let's add some detail and context to the `result` variable name:

{title: "PulsarProducer.cpp"}
```cpp
const auto producerCreationResult = pulsar::createProducer(...);

if (producerCreationResult == Result.Ok) {
  // ...
}

### Naming Collection (List and Set) Variables

When naming lists and sets, you should use the plural form of a noun, like *customers*, *errors*, or *tasks*. These kinds of names work well in the code, for example:

```ts
function handle(customers: Customer[]): Customer[] {
  // ...
}

const customers = [new Customer()];

for (const customer of customers) {
  // ...
}

const processedCustomers = handle(customers);

function isEven(integer: number): boolean {
  return integer % 2 === 0;
}

const integers = [1, 2, 3, 4, 5];
const evenIntegers = integers.filter(isEven);
```

This plural noun naming convention is usually enough because you don't necessarily need to know the underlying collection implementation. Using this naming convention
allows you to change the type of a collection variable without changing the variable name.
If you are iterating over a collection, it does not matter if it is a list or set. Thus, it does not bring any
benefit if you add the collection type name to the variable name, for example, *customerList* or *taskSet*. Those names are just longer.
You might want to specify the collection type in some special cases. Then, you can use the following kinds of variable names:
*queueOfTasks*, *stackOfCards*, or *setOfTimestamps*.

Below is an example in Go language, where the function is named correctly to return a collection (of categories), but the variable
receiving the return value is not named according to the collection variable naming convention:

```go
vmsdata, error = vmsClient.GetCategories(vmsUrl, logger)
```

Correct naming would be:

```go
vmsCategories, error = vmsClient.GetCategories(vmsUrl, logger)
```

### Naming Map Variables

Maps are accessed by requesting a _value_ for a certain _key_. This is why I recommend naming maps using the pattern _keyToValue_ or keyToValueMap_.
Let’s say we have a map containing order counts for customer ids. This map should be named `customerIdToOrderCount` or `customerIdToOrderCountMap`.
Or if we have a list of suppliers for product names, the map variable should be named `productNameToSuppliers` or `productNameToSuppliersMap`.
Below is an example of accessing maps in Java:

```java
final var orderCount = customerIdToOrderCount.get(customerId);
final var suppliers = productNameToSuppliers.get(productName);
```

Below is an example of iterating over a map in JavaScript:

```ja
Object.entries(customerIdToOrderCount)
      .map(([customerId, orderCount]) => ...);
```

### Naming Pair and Tuple Variables

A variable containing a pair should be named using the pattern _variable1AndVariable2_. For example: `heightAndWidth`. And for tuples,
the recommended naming pattern is _variable1Variable2...andVariableN_. For instance: `heightWidthAndDepth`.

Below is an example of using pairs and tuples in JavaScript:

```js
const heightAndWidth = [100, 200];
const heightWidthAndDepth = [100, 200, 40];
const [height, , depth] = heightWidthAndDepth;
```

### Naming Object Variables

Object variables refer to an instance of a class. Class names are nouns written in CapWords, like
*Person*, *CheckingAccount*, or *Task*. Object variable names should contain the related class name: a *person* object of
the *Person* class, an *account* object of the *Account* class, etc. You can freely decorate the object’s name, for example, with
an adjective: *completedTask*. Including the class name or at least a significant part of it at the end of the variable name is useful because looking at the end of the variable name tells what kind of object is in question.

Do not add an article `a` or `an` to an object variable's name. This is redundant because you usually know if it is
a question about an object variable when you follow all the naming conventions presented in this book.

```java
// Not so good
writeTo(aBuffer, aMessage)

// Better
write(message, buffer)
```

Sometimes you might want to name an object variable so that the name of its class is implicit, for example:

```java
// The class of the function parameters, 'Location', is implicit
drive(home, destination);
```

In the above example, the classes of `home` and `destination` objects are not explicit. In most cases, it is preferable to make the class name
explicit in the variable name when it does not make the variable name too long. This is because of the variable type deduction.
The types of variables are not necessarily visible in the code, so the type of a variable should be communicated by the
variable name. Below is an example where the types of function parameters are explicit.<div class="sourceCodeWithoutLabel">

```java
// The class of the function parameters, 'Location', is now explicit
drive(homeLocation, destLocation);
```

### Naming Optional Variables

How to name optional variables depends on the programming language and how the optional types are implemented. An optional
variable name should be prefixed with _maybe_ in languages where you need to unwrap the possible value from an optional object.

In Java, when using Optional&lt;T&gt;, name variables of this type using the following pattern: _maybe&lt;Something&gt;_:

```java
maybeLoggedInUser.ifPresent(loggedInUser -> loggedInUser.logout());
final User currentUser = maybeLoggedInUser.orElse(guestUser);
```

In TypeScript and other languages where optional types are created using type unions, you don’t need any prefixes
in optional variable names. In the below example, the `discount` parameter is optional, and its type is `number | undefined`:

```ts
function addTax(
  price: number,
  discount?: number
): number {
  return 1.2 * (price — (discount ?? 0));
}

const priceWithTax = addTax(priceWithoutTax);
```

### Naming Function Variables (Callbacks)

Callback functions are functions supplied to other functions to be called at some point. If a callback function returns a value,
it can be named according to the returned value, but it should still contain a verb.
If the callback function does not return a value, you should name the callback function like any other function:
Indicating what the function does. Suppose you have a variable storing a function object, like a Java `Function` instance. In that case, you need to name the variable according to the rules for an object variable, i.e., the variable name should be a noun. For example, if you have a Java `Function` object currently named `map`, you should correct the name to be a noun, like `mapper`.

```js
const doubled = value => 2 * value;
const squared = value => value * value;
const isEven = nbr => (nbr % 2) === 0;
const values = [1, 2, 3, 4, 5]

// You can imagine an implicit "to" preposition after the map function name
const doubledValues = values.map(doubled);
const squaredValues = values.map(squared);

const evenValues = values.filter(isEven);

const strings = [" string1", "string2 "];
const trimmed = str => str.trim();
const trimmedStrings = strings.map(trimmed);

const sumOfValues = (sum, value) => sum + value;
// You can imagine an implicit "to" preposition after the reduce function name
values.reduce(sumOfValues, 0);
```

Let's have a quick detour with an example written in Clojure:

```clojure
(defn print-first-n-doubled-integers [n]
  (println (take n (map (fn [x] (* 2 x)) (range)))))
```

To understand what happens in the above code, you should start reading from the innermost function call and
proceed toward the outermost function call. A function call is inside parenthesis. When traversing the function call hierarchy, the difficulty lies in storing
and retaining information about all the nested function calls in short-term memory.

We could simplify reading the above example by naming the anonymous function and introducing variables (constants) for intermediate
function call results. Of course, our code becomes more prolonged, but coding is not a competition to write the shortest possible code
but to write the shortest, most readable, and understandable code for other people and your future self. It is a compiler's job
to compile the longer code below into code that is as efficient as the shorter code above.

Below is the above code refactored:

```clojure
(defn print-first-n-doubled-integers [n]
  (let [doubled (fn [x] (* 2 x))
        doubled-integers (map doubled (range))
        first-n-doubled-integers (take n doubled-integers)]
          (println first-n-doubled-integers)))
```

Let's think hypothetically: if Clojure's `map` function took parameters in a different order and the `range` function was
named `integers` and the `take` function was named `take-first` (like there is the `take-last` function), we would have an even more explicit version
of the original code:

```clojure
(defn print-first-n-doubled-integers [n]
  (let [doubled (fn [x] (* 2 x))
        doubled-integers (map (integers) doubled)
        first-n-doubled-integers (take-first n doubled-integers)]
          (println first-n-doubled-integers)))
```

There is a reason why the `map` function takes the parameters in that order. It is to make function partial application
possible.

### Naming Class Properties

Class properties (i.e., class attributes, fields, or member variables) should be named so that the class name is not repeated in the
property names. Below is a Java example of incorrect naming:

```java
public class Order {
  private long orderId;
  private OrderState orderState;
}
```

Below is the above code with corrected names:

```java
public class Order {
  private long id;
  private OrderState state;
}
```

If you have a class property to store a callback function (e.g., event handler or lifecycle callback), you should name it so that it tells on what occasion the stored
callback function is called. Name properties storing event handlers using the
following pattern: `on` + `<event-type>`, e.g., `onClick` or `onSubmit`. Name properties storing lifecycle callbacks in a similar way you
would name a lifecycle method, for example: `onInit`, `afterMount`, or `beforeMount`.

### General Naming Rules

#### Use Short, Common Names

When picking a name for something, use the most common shortest name. If you have a function named _relinquishSomething_, consider a shorter and more common name for the function. You could rename the function to _releaseSomething_, for example. The word "release" is
shorter and more common than the "relinquish" word. Use
Google to search for word synonyms, e.g., "relinquish synonym", to find the shortest and most common similar term.

#### Pick One Term And Use It Consistently

Let's assume that you are building a data exporter microservice and you are currently using the following terms in the code:
_message_, _report_, _record_ and _data_. Instead of using four different terms to describe the same thing, you should pick just one term,
like _message_, for example, and use it consistently throughout the microservice code.

Suppose you need to figure out a term to indicate a property of a class. You should pick just
one term, like _property_, and use it consistently everywhere. You should not use multiple terms like
_attribute_, _field_, and _member_ to describe a property of a class.

#### Avoid Obscure Abbreviations

Many abbreviations are commonly used, like *str* for a string, *num/nbr* for a number, *prop* for a property, or *val* for a value.
Most programmers use these, and I use them to make long names shorter. If a variable name is short, the full name should be used instead,
like *numberOfItems* instead of *nbrOfItems*. Use abbreviations in cases where the variable name otherwise becomes too long (20 or more characters).
What you should especially try to avoid is using uncommon abbreviations. For example, do not abbreviate *amount* to *amnt* or *discount* to *dscnt* because those abbreviations are not really used.

#### Avoid Too Short Or Meaningless Names

Names that are too short do not communicate what the variable is about. As loop counters, use a variable name like _index_ or _&lt;something&gt;Index_ if the loop variable is used to index something, like
an array, for example. An indexing variable should start from zero. If the loop variable is counting the number of things, use _number_ or
_&lt;something&gt;Number_ as the variable name, and start the loop counter from value one instead of zero. For example,
a loop to start five threads should be written in C++ in the following way:

```cpp
for (size_t threadNumber{1U}; threadNumber <= 5U; ++threadNumber)
{
  startThread(threadNumber);
}
```

If you don't need to use the loop counter value inside the loop, you can use a loop variable named _count_:

```cpp
for (size_t count{1U}; count <= objectCount; ++count)
{
  objects.push_back(acquireObject(std::forward<Args>(args)...));
}
```

Even if you don't agree with all naming conventions presented here and in the previous chapter, I recommend you create rules for naming code entities, like classes, functions, and variables. That would make your code look
consistent and professional. It makes the code look pretty bad if no naming conventions are used, and naming inside a single module or even a function varies dramatically. For example, a 'customers' variable is used somewhere, while a `customer_list` variable is used elsewhere, and the `customers` variable is used to store a list of customers in some place and the number of customers in another place. It is preferable if a whole development team or, even better, all development teams could share a common set of naming conventions.

## Uniform Source Code Repository Structure Principle

> ***Structuring a source code repository systematically in a certain way makes it easy for other developers to discover wanted information quickly.***

Below are examples of ways to structure source code repositories for Java, C++, and JavaScript/TypeScript microservices.
In the below examples, a containerized (Docker) microservice deployed to a Kubernetes cluster is assumed. Your CI tool might require
that the CI/CD pipeline code must reside in a specific directory. But if not, place the CI/CD pipeline code in a _cicd_ directory.

### Java Source Code Repository Structure

Below is the proposed source code repository structure for a Java microservice (Gradle build tool is used):

```
java-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── gradle
│   └── wrapper
│       └── ...
├── helm
│   └── java-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com.domain.java-service
│   │   │       └── // source code
│   │   └── resources
│   └── test
│       ├── java
│       │   └── com.domain.java-service
│       │       └── // unit test code
│       └── resources
├── .gitignore
├── build.gradle
├── gradlew
├── gradlew.bat
├── README.MD
└── settings.gradle
```

### C++ Source Code Repository Structure

Below is the proposed source code repository structure for a C++ microservice (CMake build tool is used):

```
cpp-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── helm
│   └── cpp-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   ├── // source code here
│   │   main.cpp
│   └── CMakeLists.txt
├── test
│   ├── // unit test code
│   │   main.cpp
│   └── CMakeLists.txt
├── .gitignore
├── CMakeLists.txt
└── README.MD
```

### JavaScript/TypeScript Source Code Repository Structure

Below is the proposed source code repository structure for a JavaScript/TypeScript microservice:

```
ts-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── helm
│   └── ts-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   └── // source code here
├── test
│   └── // unit test code here
├── .gitignore
├── .eslintrc.json
├── .prettier.rc
├── package.json
├── package-lock.json
├── README.MD
└── tsconfig.json
```

Unit test modules should be in the same directory as source code modules, but you can also put them in a specific *test* directory.

## Domain-Based Source Code Structure Principle

> ***Structure source code tree primarily by domains, not by technical details. Each source code directory should have a single responsibility at its abstraction level.***

Below is an example of a Spring Boot microservice's _src_ directory that is not organized by domains but is
incorrectly organized according to technical details:

```
spring-example-service/
└── src/
    └── main/java/
        └── com.silensoft.springexampleservice/
            ├── controllers/
            │   ├── AController.java
            │   └── BController.java
            ├── entities/
            │   ├── AEntity.java
            │   └── BEntity.java
            ├── errors/
            │   ├── AError.java
            │   └── BError.java
            ├── dtos/
            │   ├── ADto.java
            │   └── BDto.java
            ├── repositories/
            │   ├── DbAEntity.java
            │   ├── DbBEntity.java
            │   ├── ARepository.java
            │   └── BRepository.java
            └── services/
                ├── AService.java
                └── BService.java
```

Below is the above example modified so that directories are organized by domains:

```
spring-example-service/
└── src/
    └── main/java/
        └── com.silensoft.springexampleservice/
            ├── domainA/
            │   ├── AController.java
            │   ├── ADbEntity.java            │
            │   ├── ADto.java
            │   ├── AEntity.java
            │   ├── AError.java
            │   ├── ARepository.java
            │   └── AService.java
            └── domainB/
                ├── BController.java
                ├── BDbEntity.java
                ├── BDto.java
                ├── BEntity.java
                ├── BError.java
                ├── BRepository.java
                └── BService.java
```

You can have several levels of nested domains:

```
spring-example-service/
└── src/
    └── main/java/
        └── com.silensoft.springexampleservice/
            ├── domainA/
            │   ├── domainA-1/
            │   │   ├── A1Controller.java
            │   │   └── ...
            │   └── domainA-2/
            │       ├── A2Controller.java
            │       └── ...
            └── domainB/
                └── BController.java

```

If you want, you can create subdirectories for technical details inside a domain directory. This is the recommended
approach if, otherwise, the domain directory would contain more than 5 to 7 files. Below is an example of the _salesitem_ domain:

```
sales-item-service
└── src
    └── main/java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── dtos
                │   ├── InputSalesItem.java
                │   └── OutputSalesItem.java
                ├── entities
                │   └── SalesItem.java
                ├── errors
                │   ├── SalesItemRelatedError.java
                │   └── SalesItemRelatedError2.java
                ├── repository
                │   ├── DbSalesItem.java
                │   └── SalesItemRepository.java
                ├── service
                │   ├── SalesItemService.java
                │   └── SalesItemServiceImpl.java
                └── SalesItemController.java
```

To highlight the *clean microservice design principle*, we could also use the following kind of directory
layout:

```
sales-item-service
└── src
    └── main/java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── businesslogic
                │    ├── dtos
                │    │   ├── InputSalesItem.java
                │    │   └── OutputSalesItem.java
                │    ├── entities
                │    │   └── SalesItem.java
                │    ├── errors
                │    │   ├── SalesItemServiceError.java
                │    │   └── SalesItemServiceError2.java
                │    ├── repository
                │    │   └── SalesItemRepository.java
                │    └── service
                │        ├── SalesItemService.java
                │        └── SalesItemServiceImpl.java
                ├── RestSalesItemController.java
                └── SqlSalesItemRepository.java
```

The *businesslogic* directory could also be named *core*, *model*, or even *usecases*, especially if you are also using the *vertical slice design* principle where you put each vertical slice (feature) in a subdirectory of the *usecases* directory.

Or if we have multiple input interface adapters (controllers) and output interface adapters (repositories):

```
sales-item-service
└── src
    └── main/java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── businesslogic
                │    ├── dtos
                │    │   ├── InputSalesItem.java
                │    │   └── OutputSalesItem.java
                │    ├── entities
                │    │   └── SalesItem.java
                │    ├── errors
                │    │   ├── SalesItemServiceError.java
                │    │   └── SalesItemServiceError2.java
                │    ├── repository
                │    │   └── SalesItemRepository.java
                │    └── service
                │        ├── SalesItemService.java
                │        └── SalesItemServiceImpl.java
                ├── controllers
                │    ├── RestSalesItemController.java
                │    └── GraphQlSalesItemController.java
                └── repositories
                     ├── SqlSalesItemRepository.java
                     └── MongoDbSalesItemRepository.java
```

If you follow the *clean microservice design* principle and add or change an interface adapter (e.g., a controller or a repository),
you should not need to make any code changes to the business logic part of the service (the *businesslogic* directory).

Below is the source code directory structure for the data exporter microservice designed in the previous
chapter. There are subdirectories for the four subdomains: input, internal message, transformer, and output. There is a subdirectory created for each common
nominator in the class names. It is effortless to navigate the directory
tree when locating a particular file. Also, the number of source code files in each directory is low.
You can grasp the contents of a directory with a glance. The problem with directories containing many files
is that it is not easy to find the wanted file. For this reason, a single directory should ideally have 2-4 files. The absolute
maximum is 5-7 files.

Note that below, a couple of directories are left unexpanded to shorten the example. It should be easy for the reader
to infer the contents of the unexpanded directories.

```
src
├── common
├── input
│   ├── config
│   │   ├── parser
│   │   │   ├── json
│   │   │   │   ├── JsonInputConfigParser.cpp
│   │   │   │   └── JsonInputConfigParser.h
│   │   │   └── InputConfigParser.h
│   │   ├── reader
│   │   │   ├── localfilesystem
│   │   │   │   ├── LocalFileSystemInputConfigReader.cpp
│   │   │   │   └── LocalFileSystemInputConfigReader.h
│   │   │   └── InputConfigReader.h
│   │   ├── InputConfig.h
│   │   ├── InputConfigImpl.cpp
│   │   └── InputConfigImpl.h
│   │
│   └── message
│       ├── consumer
│       │   ├── kafka
│       │   │   ├── KafkaInputMessageConsumer.cpp
│       │   │   └── KafkaInputMessageConsumer.h
│       │   └── InputMessageConsumer.h
│       ├── decoder
│       │   ├── avrobinary
│       │   │   ├── AvroBinaryInputMessageDecoder.cpp
│       │   │   └── AvroBinaryInputMessageDecoder.h
│       │   └── InputMessageDecoder.h
│       ├── kafka
│       │   ├── KafkaInputMessage.cpp
│       │   └── KafkaInputMessage.h
│       │
│       └── InputMessage.h
├── internalmessage
    ├── field
│   ├── InternalMessage.h
│   ├── InternalMessageImpl.cpp
│   └── InternalMessageImpl.h
├── transformer
│   ├── config
│   │   ├── parser
│   │   ├── reader
│   │   ├── TransformerConfig.h
│   │   ├── TransformerConfigImpl.cpp
│   │   └── TransformerConfigImpl.h
│   ├── field
│   │   ├── copy
│   │   │   ├── CopyFieldTransformer.cpp
│   │   │   └── CopyFieldTransformer.h
│   │   ├── expression
│   │   ├── filter
│   │   ├── typeconversion
│   │   ├── FieldTransformer.h
│   │   ├── FieldTransformers.h
│   │   ├── FieldTransformaresImpl.cpp
│   │   └── FieldTransformersImpl.h
│   └── message
│       ├── MessageTransformer.h
│       ├── MessageTransformerImpl.cpp
│       └── MessageTransformerImpl.h
└── output
    ├── config
    │   ├── parser
    │   ├── reader
    │   ├── OutputConfig.h
    │   ├── OutputConfigImpl.cpp
    │   └── OutputConfigImpl.h
    └── message
        ├── encoder
        │   ├── avrobinary
        │   └── OutputMessageEncoder.h
        ├── producer
        │   ├── pulsar
        │   └── OutputMessageProducer.h
        ├── OutputMessage.h
        ├── OutputMessageImpl.cpp
        └── OutputMessageImpl.h
```
</div>

Below is the Java version of the above directory structure:

<div class="sourceCodeWithoutLabel">

```
src
├── common
├── input
│   ├── config
│   │   ├── parser
│   │   │   ├── InputConfigParser.java
│   │   │   └── JsonInputConfigParser.java
│   │   ├── reader
│   │   │   ├── InputConfigReader.java
│   │   │   └── LocalFileSystemInputConfigReader.java
│   │   ├── InputConfig.java
│   │   └── InputConfigImpl.java
│   └── message
│       ├── consumer
│       │   ├── InputMessageConsumer.java
│       │   └── KafkaInputMessageConsumer.java
│       ├── decoder
│       │   ├── InputMessageDecoder.java
│       │   └── AvroBinaryInputMessageDecoder.java
│       ├── InputMessage.java
│       └── KafkaInputMessage.java
├── internalmessage
│   ├── field
│   ├── InternalMessage.java
│   └── InternalMessageImpl.java
├── transformer
│   ├── config
│   ├── field
│   │   ├── impl
│   │   │   ├── CopyFieldTransformer.java
│   │   │   ├── ExpressionFieldTransformer.java
│   │   │   ├── FilterFieldTransformer.java
│   │   │   └── TypeConversionFieldTransformer.java
│   │   ├── FieldTransformer.java
│   │   ├── FieldTransformers.java
│   │   └── FieldTransformersImpl.java
│   └── message
│       ├── MessageTransformer.java
│       └── MessageTransformerImpl.java
└── output
    ├── config
    └── message
```

We could also structure the code according to the *clean microservice design* in the following way:

```
src/main/java
├── common
├── businesslogic
│   ├── input
│   │   ├── config
│   │   │   ├── InputConfig.java
│   │   │   ├── InputConfigImpl.java
│   │   │   ├── InputConfigParser.java
│   │   │   └── InputConfigReader.java
│   │   └── message
│   │       ├── InputMessage.java
│   │       ├── InputMsgConsumer.java
│   │       └── InputMsgDecoder.java
│   ├── internalmessage
│   │   ├── field
│   │   ├── InternalMessage.java
│   │   └── InternalMessageImpl.java
│   ├── transformer
│   │   ├── config
│   │   ├── field
│   │   │   ├── impl
│   │   │   │   ├── CopyFieldTransformer.java
│   │   │   │   ├── ExprFieldTransformer.java
│   │   │   │   ├── FilterFieldTransformer.java
│   │   │   │   └── TypeConvFieldTransformer.java
│   │   │   ├── FieldTransformer.java
│   │   │   ├── FieldTransformers.java
│   │   │   └── FieldTransformersImpl.java
│   │   └── message
│   │       ├── MsgTransformer.java
│   │       └── MsgTransformerImpl.java
│   └── output
│       ├── config
│       └── message
└── ifadapters
    ├── config
    │   ├── parser
    │   │   └── json
    │   │       ├── JsonInputConfigParser.java
    │   │       ├── JsonTransformerConfigParser.java
    │   │       └── JsonOutputConfigParser.java
    │   └── reader
    │       └── localfilesystem
    │           ├── LocalFileSystemInputConfigReader.java
    │           ├── LocalFileSystemTransformerConfigReader.java
    │           └── LocalFileSystemOutputConfigReader.java
    ├── input
    │   ├── kafka
    │   │   ├── KafkaInputMsgConsumer.java
    │   │   └── KafkaInputMessage.java
    │   └── AvroBinaryInputMsgDecoder.java
    └── output
        ├── CsvOutputMsgEncoder.java
        └── PulsarOutputMsgProducer.java
```

From the above directory structure, we can easily see the following:

- Configurations are in JSON format and read from the local file system
- For the input, Avro binary messages are read from Apache Kafka
- For the output, CSV records are produced to Apache Pulsar

Any change we want or need to make in the *ifadapters* directory should not affect the business logic part in the
*businesslogic* directory.

Below is the source code directory structure for the anomaly detection microservice designed in the previous
chapter. The _anomaly_ directory is expanded. We can see that our implementation is using
JSON for various parsing activities and self-organizing maps (SOM) is used for anomaly detection. JSON and Kafka are used
to publish anomaly indicators outside the microservice. Adding
new concrete implementations to the below directory structure is straightforward. For example, if we wanted to add YAML support
for configuration files, we could create _yaml_ subdirectories where we could place YAML-specific implementation classes.

```
src
├── anomaly
│   ├── detection
│   │   ├── configuration
│   │   │   ├── parser
│   │   │   │   ├── json
│   │   │   │   │   ├── JsonAnomalyDetectionConfigParser.cpp
│   │   │   │   │   └── JsonAnomalyDetectionConfigParser.h
│   │   │   │   └── AnomalyDetectionConfigParser.h
│   │   │   ├── AnomalyDetectionConfig.h
│   │   │   ├── AnomalyDetectionConfigFactory.h
│   │   │   ├── AnomalyDetectionConfigFactoryImpl.h
│   │   │   ├── AnomalyDetectionConfigImpl.cpp
│   │   │   └── AnomalyDetectionConfigImpl.h
│   │   ├── engine
│   │   │   ├── AnomalyDetectionEngine.h
│   │   │   ├── AnomalyDetectionEngineImpl.cpp
│   │   │   └── AnomalyDetectionEngineImpl.h
│   │   ├── rule
│   │   │   ├── parser
│   │   │   │   ├── json
│   │   │   │   │   ├── JsonAnomalyDetectionRuleParser.cpp
│   │   │   │   │   └── JsonAnomalyDetectionRuleParser.h
│   │   │   │   └── AnomalyDetectionRuleParser.h
│   │   │   ├── AnomalyDetectionRule.h
│   │   │   ├── AnomalyDetectionRuleFactory.h
│   │   │   ├── AnomalyDetectionRuleFactoryImpl.h
│   │   │   ├── AnomalyDetectionRuleImpl.cpp
│   │   │   └── AnomalyDetectionRuleImpl.h
│   │   ├── AnomalyDetector.h
│   │   ├── AnomalyDetectorImpl.cpp
│   │   └── AnomalyDetectorImpl.h
│   ├── indicator
│   │   ├── publisher
│   │   │   ├── kafka
│   │   │   │   ├── KafkaAnomalyIndicatorPublisher.cpp
│   │   │   │   └── KafkaAnomalyIndicatorPublisher.h
│   │   │   └── AnomalyIndicatorPublisher
│   │   ├── serializer
│   │   │   ├── json
│   │   │   │   ├── JsonAnomalyIndicatorSerializer.cpp
│   │   │   │   └── JsonAnomalyIndicatorSerializer.h
│   │   │   └── AnomalyIndicatorSerializer.h
│   │   ├── AnomalyIndicator.h
│   │   ├── AnomalyIndicatorFactory.h
│   │   ├── AnomalyIndicatorFactoryImpl.h
│   │   ├── AnomalyIndicatorImpl.cpp
│   │   └── AnomalyIndicatorImpl.h
│   └── model
│       ├── som
│       │   ├── SomAnomalyModel.cpp
│       │   ├── SomAnomalyModel.h
│       │   └── SomAnomalyModelFactory.h
│       ├── training
│       │   ├── engine
│       │   │   ├── AnomalyModelTrainingEngine.h
│       │   │   ├── AnomalyModelTrainingEngineImpl.cpp
│       │   │   └── AnomalyModelTrainingEngineImpl.h
│       │   ├── som
│       │   │   ├── SomAnomalyModelTrainer.cpp
│       │   │   └── SomAnomalyModelTrainer.h
│       │   └── AnomalyModelTrainer.h
│       ├── AnomalyModel.h
│       └── AnomalyModelFactory.h
├── common
├── measurement
├── Application.h
├── Application.cpp
├── DependencyInjector.h
└── main.cpp
```

Let's have one more example with a _data-visualization-web-client_.

This web client's UI consists of the following pages, which all include a common header:

- Dashboards
- Data Explorer
- Alerts

The *Dashboards* page contains a dashboard group selector, dashboard selector, and chart area to display the selected dashboard's charts.
You can select the shown dashboard by first selecting a dashboard group and then a dashboard from that group.

![Dashboards Page](resources/chapter3/images/dashboards_page.png)

The *Data Explorer* page contains selectors for choosing a data source, measure(s), and dimension(s). The page also contains
a chart area to display charts. Using the selectors, a user can change the shown measure(s) and dimension(s) for
the currently selected chart in the chart area.

![Data Explorer Page](resources/chapter3/images/data_explorer_page.png)

Based on the above design, the web client can be divided into the following subdomains:

- Common UI components
  - Chart Area
    - Chart
- Header
- Pages
  - Alerts
  - Dashboards
  - Data Explorer

The source code tree should look like the following:

```
src
├── app
│   ├── common
│   │   └── chartarea
│   │       └── chart
│   ├── header
│   └── pages
│       ├── alerts
│       ├── dashboards
│       │   └── selectors
│       │       ├── dashboardgroup
│       │       └── dashboard
│       └── dataexplorer
│           └── selectors
│               ├── datasource
│               ├── dimension
│               └── measure
├── index.ts
└── store.ts
```

Below is an example of what a single subdomain directory would look like when using React, Redux, and
SCSS modules:

```
src
├── app
│   └── header
│       ├── model
│       │   ├── actions
│       │   │   ├── AbstractHeaderAction.ts
│       │   │   └── NavigateToPageAction.ts
│       │   └── state
│       │       ├── types
│       │       ├── HeaderState.ts
│       │       └── initialHeaderState.ts
│       ├── service
│       ├── view
│       │    ├── navigation
│       │    │   ├── NavigationView.module.scss
│       │    │   └── NavigationView.tsx
│       │    ├── HeaderView.module.scss
│       │    └── HeaderView.tsx
│       └── headerController.ts
├── index.ts
└── store.ts
```

In the above example, we have created two directories for the technical details of the *header* domain: model, service, and view directories. The model directory
contains actions and the state, and the view directory contains the view component, its possible subcomponents, and
CSS definitions. The model's state directory can contain a subdirectory for types
used in the subdomain state. The state directory should always contain the type definition for the subdomain's state and the initial state.
The service directory contains one or more services that use the respective backend services to control the backend model.

## Avoid Comments Principle

> ***Avoid comments in code. The only exception is when documenting the public API of a library.***

Comments can be problematic. You cannot trust them 100% because they can be misleading, outdated, or downright wrong. You can only
trust the source code itself. Comments are often entirely unnecessary and only make the code more verbose. Allowing comments can produce
unreadable code containing bad names, which are explained by attaching comments. The code typically also contains long functions where functionality blocks
are described with attached comments instead of refactoring the code by extracting well-named functions. The idea behind this principle is that
when writing comments is disallowed, you are forced to communicate better with the code only.
The following sections describe several ways to avoid writing comments and still keep your code understandable. The following things
can be done to avoid writing comments:

- Name things like classes, functions, and variables properly
  - For example, if you are using a particular algorithm, don't document that algorithm in a comment, but name the respective class/function
    so that it contains the algorithm name. Readers can then google the algorithm by name if unfamiliar with it
- You should not add comments about variable/function types. Use type annotations everywhere
- You don't need to comment that a function can raise an error. Use the function name *try* prefix convention described later in this chapter
- Don't add a comment to a piece of code, but extract a new well-named function
- Keep your functions small. They are easier to understand because they cannot contain too complex logic that could justify a comment
- Don't add as a comment information that can be obtained from the version control system
- Don't comment out the code. Just remove the unused code. The removed code will be available in the version control system forever
- You don't have to comment on a function's logic. Code readers should be able to infer that information from the code itself
  and the related unit tests. Complex code logic and behavior do not usually need comments if you have practiced *test-driven development* and a complete set of well-named unit tests is available.

Code comments often duplicate information already available in the code itself or related tests. This is called information duplication, which should be avoided according to the *don't repeat yourself* (DRY) principle. This principle was introduced in the *Pragmatic Programmer* book by *David Thomas* and *Andrew Hunt*.

Comments for a public API in a library are needed because the library needs API documentation that can be
automatically generated from the comments to avoid situations where API comments and docs are out of sync.
API documentation is usually unnecessary in non-library software components because you can access the API interface,
implementation, and unit tests. The unit tests, for example, specify what the function does in different scenarios. The unit test name
tells the scenario, and the expectations and assertions in the unit test code tell the expected behavior in the particular situation.
API implementation and unit tests are not typically available for library users, and even if they are,
a user should not adhere to them because they are internal details subject to change.

### Name Things Properly

When you name things like a function poorly, you might end up attaching a comment to the function. To avoid writing comments, it is imperative to focus on naming things correctly. When following the _single responsibility principle_
and the _uniform naming principle_, it should be easier to name things correctly and avoid comments. Below is a C++ example of
a function with a comment:

{title: MessageBuffer.h}
```cpp
class MessageBuffer
{
public:
  // Return false if buffer full,
  // true if message written to buffer
  bool write(const std::shared_ptr<Message>& message);
}
```

If we drop the comment, we will have the following code:

{title: MessageBuffer.h}
```cpp
class MessageBuffer
{
public:
  bool write(const std::shared_ptr<Message>& message);
}
```

Dropping the comment alone is not the best solution because some crucial information is now missing. What does that boolean return
value mean? It is not 100% clear. We can assume that returning `true` means that message was successfully written, but
nothing is communicated about returning `false`. We can only assume it is some error, but not sure what error.

In addition to removing the comment, we should give a better name for the function and rename it as follows:

{title: MessageBuffer.h}
```cpp
class MessageBuffer
{
public:
  bool writeIfBufferNotFull(
    const std::shared_ptr<Message>& message
  );
}
```

Now the purpose of the function is clear, and we can be sure what the boolean return value means. It
means whether the message was written to the buffer. Now we also know why the writing of a message can fail: the
buffer is full. This will give the function caller sufficient information about what to do next. It should
probably wait a while so that the buffer reader has enough time to read messages from the buffer
and free up some space.

Below is a real-life example of C++ code where the comment and the function name do not match.

```cpp
  /**
   * @brief Add new counter or get existing, if same labels used already.
   * @param counterName Name of the counter
   * @param help Help text added for counter, if new countername
   * @param labels Specific labels for counter.
   * @return counter pointer used when increasing counter, or nullptr
   *         if metrics not initialized or invalid name or labels
  */
  static prometheus::Counter* addCounter(
    std::string counterName,
    std::string help,
    const std::map<std::string, std::string>& labels
  );
```

In the above example, the function name tells it adds a counter, but the comment says it adds or gets an existing counter.
The real problem is that once someone first reads the function name `addCounter`, they do not necessarily
read the 'brief' in the comments because they immediately understand what the function does after reading its name: it should add a counter.
We could improve the function's name and rename it to `addOrGetExistingCounter` as a solution.

Below is a real-life Java example from a book that I once read:

```java
public interface Mediator {
  // To register an employee
  void register(Person person);

  // To send a message from one employee to another employee
  void connectEmployees(
    Person fromPerson,
    Person toPerson,
    String msg
  );

  // To display currently registered members
  void displayDetail();
}
```

There are three functions in the above example, each of which has a problem.
The first function is registering a person, but the comment says it is registering an employee. So, there is a mismatch
between the comment and the code. In this case, I trust the code over the comment. The correction is to remove the comment
because it does not bring any value. It only causes confusion.

The second function says in the comment that it sends a message from one employee to another. The function name tells
about connecting employees, but the parameters are persons. I assume that a part of the
comment is correct: to send a message from someone to someone else. But once again, I trust the code
more over the comment and assume the message is sent from one person to another. We should remove the comment and rename the function.

In the third function, the comment adds information missing from the function name. The comment also
discusses members, as other parts of the code speak about employees and persons. There are three different
terms used: employee, person, and member. Just one term should be picked. Let's choose the term _person_ and use it systematically.

Below is the refactored version without the comments:

```java
public interface Mediator {
  void register(Person person);

  void send(
    String message,
    Person sender,
    Person recipient
  );

  void displayDetailsOfRegisteredPersons();
}
```

### Single Return Of Named Value At The End Of Function

> ***A function should have a single return statement and return a named value at the end of the function. This allows the code reader to infer the meaning of the return value by looking at the end of the function.***

This principle is relevant for return types that do not convey enough semantic meaning like a number or a string.

Consider the following C++ example:

{title: "Metrics.h"}
```cpp
class Metrics
{
public:
  // ...

  static uint32_t addCounter(
    CounterFamily counterFamily,
    const std::map<std::string, std::string>& labels
  );

  static void incrementCounter(
    uint32_t counterIndex,
    size_t incrementAmount
  );

  // addGauge...
  // setGaugeValue...
}
```

What is the return value of the `addCounter` function? Someone might think a comment is needed to describe
the return value because it is unclear what `uint32_t` means. Instead of writing a comment, we can introduce a named value
(= variable/constant) to be returned from the function. The idea behind the named return value is that it communicates the semantics of the return
value without the need for a comment. In C++, you jump from the function declaration to the function definition to see
what the function returns. Below is the implementation for the `addCounter` function:

{title: "Metrics.cpp"}
```cpp
uint32_t Metrics::addCounter(
  const CounterFamily counterFamily,
  const std::map<std::string, std::string>& labels)
{
  uint32_t counterIndex;

  // Perform adding a counter here and
  // set value for the 'counterIndex'

  return counterIndex;
}
```

In the above implementation, we have a single return of a named value at the end of the function. All we have to do is to look
at the end of the function and spot the return statement, which should tell us the meaning of the mysterious `uint32_t`
typed return value: It is a counter index. And we can spot that the `increaseCounter` function requires a `counterIndex` argument
and this establishes a connection between calling the `addCounter` function first, storing the returned counter index, and
later using that stored counter index in calls to the `increaseCounter` function.

### Return Type Aliasing

In the previous example, there was the mysterious return value of type `uint32_t` in the `addCounter` function. We learned how
introducing a named value returned at the end of the function helped to communicate the semantics of the return value. But there is
an even better way to communicate the semantics of a return value. Many languages like C++ and TypeScript offer type aliasing that
can be used to communicate the return value semantics. Below is a C++ example where we introduce a `CounterIndex` type alias
for the `uint32_t` type:

{title: "Metrics.h_"}
```cpp
class Metrics
{
public:
  using CounterIndex = uint32_t;

  // ...

  static CounterIndex addCounter(
    CounterFamily counterFamily,
    const std::map<std::string, std::string>& labels
  );

  static void incrementCounter(
    CounterIndex counterIndex,
    size_t incrementAmount
  );
}
```

And here is the same example in TypeScript:

{title: "Metrics.ts"}
```ts
export type CounterIndex = number;

export default class Metrics {
  // ...

 static addCounter(
    counterFamily: CounterFamily,
    labels: Record<string, string>
  ): CounterIndex;

  static incrementCounter(
    counterIndex: CounterIndex,
    incrementAmount: number
  ): void;
}
```

Some languages, like Java, don't have type aliases. Then you can introduce a wrapper class for the returned value. Here is the same example in Java:

{title: "CounterIndex.java"}
```
public class CounterIndex {
  private final int value;

  public CounterIndex(final int value) {
    this.value = value;
  }

  public int get() {
    return value;
  }
}
```

{title: "Metrics.java"}
```java
public final class Metrics {
  // ...

  public static CounterIndex addCounter(
    final CounterFamily counterFamily,
    final Map<String, String> labels
  ) {
    // ...
  }

  public static void incrementCounter(
    CounterIndex counterIndex,
    double incrementAmount
  ) {
    // ...
  }
}
```

We can improve the above example. The `CounterIndex` class could be derived from a generic `Value` class:

```java
public class Value<T> {
  private final T value;

  public Value(final T value) {
    this.value = value;
  }

  public T get() {
    return value;
  }
}

public class CounterIndex extends Value<Integer> {
  // ...
}
```

We can improve the above metrics example a lot. First, we should avoid the primitive type obsession. We should not be returning an index
from the `addCounter` method, but we should rename the method as `createCounter` and return an instance of a `Counter` class from
the method. Then we should make the example more object-oriented by moving the `incrementCounter` method to the `Counter` class
and naming it just `increment`. Also, the name of the `Metrics` class should be changed to `MetricFactory`. And finally,
we should make the `MetricFactory` class a singleton instead of containing static methods.

### Extract Constant for Boolean Expression

By extracting a constant for a boolean expression, we can eliminate comments. Below is an example where a comment is written
below an if-statement and its boolean expression:

{title: "MessageBuffer.cpp"}
```cpp
bool MessageBuffer::writeIfBufferNotFull(
  const std::shared_ptr<Message>& message
) {
  bool messageWasWritten{false};

  if (m_messages.size() < m_maxBufferSize)
  {
    // Buffer is not full
    m_messages.push_back(message);
    messageWasWritten = true;
  }

  return messageWasWritten;
}
```

By introducing a constant to be used in the "buffer is full" check, we can get rid of the "Buffer is not full" comment:

{title: "MessageBuffer.cpp"}
```cpp
bool MessageBuffer::writeIfBufferNotFull(
  const std::shared_ptr<Message> message
) {
  bool messageWasWritten{false};

  const bool bufferIsNotFull =
    m_messages.size() < m_maxBufferSize;

  if (bufferIsNotFull)
  {
    m_messages.push_back(message);
    messageWasWritten = true;
  }

  return messageWasWritten;
}
```

When writing comparison expressions, remember to write the comparison so that it is fluent to read:

```ts
# Wrong, not fluent to read
if ('John' === customerName) {
  // ...
}

# Correct
if (customerName === 'John') {
  // ...
}

# Wrong
bufferIsNotFull = maxLength > messages.length;

# Correct
bufferIsNotFull = messages.length < maxLength;
```

You should also have matching names for the variables being compared:

```ts
# Correct
bufferIsNotFull = messages.length < maxLength;

# Incorrect
# Left side of comparison speaks about length and
# right side speaks about size
bufferIsNotFull = messages.length < maxSize;
```

### Extract Named Constant or Enumerated Type

If you encounter a [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)) in your code, you should introduce either a named constant or an enumerated type (enum) for that value.
In the below example, we are returning two magic numbers, 0 and 1:

{title: "main.cpp"}
```cpp
int main()
{
  Application application;

  if (application.run())
  {
    // Application was run successfully
    return 0;
  }

  // Exit code: failure
  return 1;
}
```

Let's introduce an enumerated type, `ExitCode,` and use it instead of magic numbers:

{title: "main.cpp"}
```
enum class ExitCode
{
  Success = 0,
  Failure = 1
};

int main()
{
  Application application;
  const bool appWasRun = application.run();

  return static_cast<int>(
    appWasRun ? ExitCode::Success : ExitCode::Failure
  );
}
```

It is now easy to add more exit codes with descriptive names later if needed.

### Extract Function

If you are planning to write a comment above a piece of code, you should extract that piece of code to a new function. When you extract a well-named function, you don't need to write that comment. The name
of the newly extracted function serves as documentation. Below is an example with some commented code:

{title: "MessageBuffer.cpp"}
```cpp
void MessageBuffer::writeFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  if (m_messages.size() + messages.size() <= m_maxBufferSize)
  {
    // All messages fit in buffer
    m_messages.insert(m_messages.end(),
                      messages.begin(),
                      messages.end());

    messages.clear();
  }
  else
  {
    // All messages do not fit, write only messages that fit
    const auto messagesEnd = messages.begin() +
                             m_maxBufferSize -
                             m_messages.size();

    m_messages.insert(m_messages.end(),
                      messages.begin(),
                      messagesEnd);

    messages.erase(messages.begin(), messagesEnd);
  }
}
```

Here is the same code with comments refactored out by extracting two new methods:

{title: "MessageBuffer.cpp"}
```cpp
void MessageBuffer::writeFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  const bool allMessagesFit = m_messages.size() +
                              messages.size() <= m_maxBufferSize;

  if (allMessagesFit)
  {
    writeAll(messages)
  }
  else
  {
    writeOnlyFitting(messages);
  }
}

void MessageBuffer::writeAll(
  std::deque<std::shared_ptr<Message>>& messages
) {
  m_messages.insert(m_messages.end(),
                    messages.begin(),
                    messages.end());

  messages.clear();
}

void MessageBuffer::writeOnlyFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  const auto messageCountThatFit = m_maxBufferSize -
                                   m_messages.size();

  const auto messagesEnd = messages.begin() +
                           messageCountThatFit;

  m_messages.insert(m_messages.end(),
                    messages.begin(),
                    messagesEnd);

  messages.erase(messages.begin(), messagesEnd);
}
```

### Avoid Comments for Regular Expression

When you have a complex regular expression, you might be tempted to attach a comment to it to explain the meaning
of it. But there is an alternative way. You can split the complex regular expression into well-named parts and construct the final regular expression from those well-named parts. For example, suppose you must create a regular expression to validate phone numbers in the international format. In that case, you can split the regular expression into
the following parts: plus sign, country code, area code, and the rest of the phone number (local number). You can define
the regular expression using the parts: `intlPhoneNbrRegExpr = plusSign + countryCode + areaCode +
localNumber`.

### Name Anonymous Function

Anonymous functions are common in functional programming, e.g., when using
algorithms like _forEach_, _map_, _filter_, and _reduce_. When an anonymous function is long or complex, you should give it a descriptive name and split it into multiple functions
if it is too long. This way, you can eliminate comments.

In the below TypeScript example, we have an anonymous function with a comment:

```ts
// ...

fs.watchFile('/etc/config/LOG_LEVEL', () => {
  // Update new log level
  try {
    const newLogLevel = fs.readFileSync('/etc/config/LOG_LEVEL',
                                        'utf-8'}).trim();
    tryValidateLogLevel(newLogLevel);
    process.env.LOG_LEVEL = newLogLevel;
  } catch (error) {
    // ...
  }
});
```

We can refactor the above example so that the comment is removed and
the anonymous function is given a name:

```ts
function updateNewLogLevel() {
  try {
    const newLogLevel = fs.readFileSync('/etc/config/LOG_LEVEL',
                                        'utf-8'}).trim();
    tryValidateLogLevel(newLogLevel);
    process.env.LOG_LEVEL = newLogLevel;
  } catch (error) {
    // ...
  }
}

fs.watchFile('/etc/config/LOG_LEVEL', updateNewLogLevel);
```

### Avoiding Comments in Bash Shell Scripts

Many programmers, myself included, don't enjoy the mysterious syntax of Linux shell commands and scripts.
Even the syntax of the simplest expressions can be hard to understand and remember if you don't regularly work
with scripts and commands. Of course, the best thing is to avoid writing complex Linux shell scripts and
use a proper programming language like Python instead. But sometimes, performing some actions
using a shell script is easier. Because the syntax and commands in shell scripts can be hard to understand, many developers tend to
solve the problem by adding comments to scripts.

Next, alternative ways to make scripts more understandable
without comments are presented. Let's consider the below example from one real-life script I have bumped into:

```bash
create_network() {
  #create only if not existing yet
  if [[ -z "$(docker network ls | grep $DOCKER_NETWORK_NAME )" ]];
  then
    echo Creating $DOCKER_NETWORK_NAME
    docker network create $DOCKER_NETWORK_NAME
  else
    echo Network $DOCKER_NETWORK_NAME already exists
  fi
}
```

Below is the same example with the following changes:

- The comment was removed, and the earlier commented expression was moved to a well-named function
- The negation in the expression was removed, and the contents of the *then* and *else* branches were swapped
- Variable names were made camel case to enhance readability. All-caps names are harder to read.

```bash
dockerNetworkExists() { [[ -n "$(docker network ls | grep $1 )" ]]; }

createDockerNetwork() {
  if dockerNetworkExists $networkName; then
    echo Docker network $networkName already exists
  else
    echo Creating Docker network $networkName
    docker network create $networkName
  fi
}
```

If your script accepts arguments, give the arguments proper names, for example:

```bash
dataFilePathName=$1
schemaFilePathName=$2
```

The script reader does not have to remember what `$1` or `$2` means, and you don't have to insert
any comments to clarify the meaning of the arguments.

If you have a complex command in a Bash shell script, you should not attach a comment to it but extract a function
with a proper name to describe the command.

The below example contains a comment:

```bash
# Update version in Helm Chart.yaml file
sed -i "s/^version:.*/version: $VERSION/g" helm/service/Chart.yaml
```

Here is the above example refactored to contain a function and a call to it:

```bash
updateHelmChartVersionInChartYamlFile() {
  sed -i "s/^version:.*/version: $1/g" helm/service/Chart.yaml
}

updateHelmChartVersionInChartYamlFile $version
```

Here is another example:

```bash
getFileLongestLineLength() {
  echo $(awk '{ if (length($0) > max) max = length($0) } END { print max }' $1)
}

configFileLongestLineLength = $(getFileLongestLineLength $configFilePathName)
```

## Function Single Return Principle

> ***Prefer a single return statement at the end of a function to clearly communicate the return value's meaning and make refactoring the function easier.***

A single return statement with a named value at the end of a function clearly communicates the return value semantics
if the return value type does not directly communicate it. For example, if you return a value of a primitive
type like an integer or boolean from a function, it is not necessarily 100% clear what the return value means. But when you return a named value at the end of the
function, the name of the returned variable communicates the semantics.

You might think that being unable to return a value in the middle of a function would make
the function less readable because of lots of nested if-statements. This is possible, but one should remember that a function should be small. Aim to have a maximum of 5-9 lines of statements
in a single function. Following that rule, you never have _a hell of nested if-statements_ inside
a single function.

Having a single return statement at the end of a function makes refactoring the function easier. You can use automated
refactoring tools provided by your IDE. It is always harder to extract a new function from code containing
a return statement. The same is true for loops with a _break_ or _continue_ statement. It is easier to refactor code
inside a loop that does not contain a break or continue statement.

In some cases, returning a single value at the end of a function makes the code more straightforward and requires fewer lines of code.

Below is an example of a function with two return locations:

{title: "TransformThread.cpp"}
```cpp
bool TransformThread::transform(
  const std::shared_ptr<InputMessage>& inputMessage
) {
  auto outputMessage = m_outputMessagePool->acquireMessage();
  bool messageIsFilteredIn;

  const bool messageWasTransformed =
    m_messageTransformer->transform(inputMessage,
                                   outputMessage,
                                   messageIsFilteredIn);

  if (messageWasTransformed && messageIsFilteredIn)
  {
    m_outputMessages.push_back(outputMessage);
  }
  else
  {
    m_outputMessagePool->returnMessage(outputMessage);

    if (!messageWasTransformed)
    {
        return false;
    }
  }

  return true;
}
```

When analyzing the above function, we notice that it transforms an input message into an output message.
We can conclude that the function returns _true_ on successful message transformation. We can shorten the function by refactoring
it to contain only one return statement. After refactoring, it is 100% clear what the function return value means.

{title: "TransformThread.cpp"}
```cpp
bool TransformThread::transform(
  const std::shared_ptr<InputMessage>& inputMessage
) {
  auto outputMessage = m_outputMessagePool->acquireMessage();
  bool messageIsFilteredIn;

  const bool messageWasTransformed =
      m_messageTransformer->transform(inputMessage,
                                      outputMessage,
                                      messageIsFilteredIn);

  if (messageWasTransformed && messageIsFilteredIn)
  {
    m_outputMessages.push_back(outputMessage);
  }
  else
  {
    m_outputMessagePool->return(outputMessage);
  }

  return messageWasTransformed;
}
```

As an exception to this rule, you can have multiple return statements in a function when the function has optimal length and would become too long if it is refactored to contain a single return statement.
Additionally, it is required that the semantic meaning of the return value is clear from the function name or the return type of the function. This is usually true if the return value is a boolean value or
an object. In case of multiple return statements, you can use so-called [guard clauses](https://en.wikipedia.org/wiki/Guard_(computer_science)) at the beginning of the function. These guard clauses are if-statements that can return early from the function if a
certain condition is met. You can have multiple guard clauses. Here is a Java example of a guard clause:

```java
public Optional<Session> getSession(final String userName){
    if (userName.isEmpty()) {
        return Optional.empty();
    }

    // Rest of the method code follows here...
}

Below is an example of a function with multiple return statements. It is also clear
from the function name what the return value means. Also, the length of the function is optimal: seven statements.

```ts
private areEqual(
  iterator: MyIterator<T>,
  anotherIterator: MyIterator<T>
): boolean {
  while (iterator.hasNextElement()) {
    if (anotherIterator.hasNextElement()) {
      if (iterator.getNextElement() !==
          anotherIterator.getNextElement()) {
       return false;
      }
    } else {
      return false;
    }
  }

  return true;
}
```

If we refactored the above code to contain a single return statement, the code would become too long (10 statements) to fit in one function, as shown below. In this case, we should prefer the above code over the below code.

```ts
private areEqual(
  iterator: MyIterator<T>,
  anotherIterator: MyIterator<T>
): boolean {
  let areEqual = true;

  while (iterator.hasNextElement()) {
    if (anotherIterator.hasNextElement()) {
      if (iterator.getNextElement() !==
          anotherIterator.getNextElement()) {
       areEqual = false;
       break;
      }
    } else {
      areEqual = false;
      break;
    }
  }

  return areEqual;
}
```

As the second exception to this rule, you can use multiple return locations in a factory because you know
from the factory name what type of objects it creates. Below is an example factory with multiple return statements:

```cpp
enum class CarType
{
  Audi,
  Bmw,
  MercedesBenz
};

class Car
{
  // ...
};

class Audi : public Car
{
  // ...
};

class Bmw : public Car
{
  // ...
};

class MercedesBenz : public Car
{
  // ...
};

class CarFactory
{
public:
  std::shared_ptr<Car> createCar(const CarType carType)
  {
    switch(carType)
    {
      case CarType::Audi:
        return std::make_shared<Audi>();
      case CarType::Bmw:
        return std::make_shared<Bmw>();
      case CarType::MercedesBenz:
        return std::make_shared<MercedesBenz>();
      default:
        throw std::invalid_argument("Unknown car type");
    }
  }
};
```

## Use Type Annotations for Production Code Principle

> ***Use type annotations when implementing production software. You can use untyped Python for non-production code like integration, end-to-end, and automated non-functional tests.***

You can manage with a trivial software component without types, but when it grows bigger, and more people are involved, the benefits of static typing become evident.

Let's analyze what potential problems using an untyped language might incur:

- Function arguments might be given in the wrong order
- Function argument might be given with the wrong type
- Function return value type might be misunderstood
- Refactoring code is more difficult
- Forced to write public API comments to describe function signatures
- Type errors are not necessarily found in testing

### Function Arguments Might Be Given in Wrong Order

When not using type annotations for functions, you can accidentally give function arguments in the wrong order.
When you use type annotations, this kind of error is less common. Modern IDEs can display inlay hints for parameters in a function call. This is a feature you should consider enabling in your IDE.
Those parameter hints might reveal cases where arguments for a function are not given in the correct order.

### Function Argument Might Be Given with Wrong Type

You can give a function argument with the wrong type when type annotations are not used. For example,
a function requires a string representation of a number, but you provide a number. Naming function arguments correctly can help. Instead of
naming a string argument, *amount*, the argument should be named as *amountString* or *amountAsString*.

### Function Return Value Type Might Be Misunderstood

Determining the function return value type can be difficult. It is not necessarily 100% clear from the name of the function. For example,
if you have a function named `getValue`, the return value type is not 100% clear. It might be apparent only if you know the context of the function well. As an improvement,
the function should be appropriately named, for example: `getValueAsString()`, if the returned value is always a string. If the return value type is unclear
when looking at the function name, you must analyze the function's source code to determine the return value
type. That is unnecessary and error-prone manual work that can be avoided using function return type annotations.

### Refactoring Code Is More Difficult

Refactoring code is usually more difficult if you don't have type annotations. But when you have type annotations and
make a change to, e.g., a function argument type, you will get type check errors in parts of code where this function
is called. Then, it is easy to refactor those parts. But if you didn't have type annotations and made this same change, you
would have to manually find all the places where a change is needed, which is clearly more error-prone.

### Forced to Write Public API Comments

You might be forced to document a public API using comments when not using type annotations.
This is additional work that could be avoided by using type annotations. Writing API documentation with
comments is error-prone. You can accidentally write wrong information in the API documentation or
forget to update the documentation when you make changes to the API code itself. Similarly, the
API documentation readers can make mistakes. They might not read the API documentation at all. Or they have read it earlier but later misremember it.

### Type Errors Are Not Found in Testing

This is the biggest problem. You might think that if you have mistakes in your code related to having correct function arguments
with the correct types, testing will reveal those mistakes. This is typically a wrong assumption.
Unit tests won't find the issues because you mock other classes and their methods. You can only find
the issues in integration testing when you integrate the software component (i.e., test functions calling
other real functions instead of mocks). According to the testing pyramid, integration tests only cover a subset of the codebase,
less than unit tests. Depending on the code coverage of the integration tests, some function argument order
or argument/return value type correctness issues may be left untested and escape to production.

## Refactoring Principle

> ***You cannot write the perfect code on the first try, so you should always reserve some time for future refactoring.***

You must refactor even if you write code for a new software component. Refactoring is not related
to legacy codebases only. If you don't refactor, you let technical debt grow in the software. The main idea
behind refactoring is that no one can write the perfect code on the first try. Refactoring means that you
change code without changing the actual functionality. After refactoring, most tests should still
pass, the code is organized differently, and you have a better object-oriented design and improved naming of things.
Refactoring does not usually affect integration tests but can affect unit tests depending on the type and scale
of refactoring. Keep this in mind when estimating refactoring effort. When you practice test-driven development (TDD), you
are bound to refactor. Refactoring is a practice built into the TDD process. In TDD, the final function implementation is a result of a series of
refactorings. This is one of the biggest benefits of TDD. We will discuss TDD more in the next chapter.

Software developers don't necessarily reserve any or enough time for refactoring when they plan things.
When we provide work estimates for epics, features, and user
stories, we should be conscious of the need to refactor and add some extra time to our initial work estimates
(which don't include refactoring). When you use TDD, you start automatically reserving some time for refactoring because refactoring is an integral part of the TDD process.
Refactoring is work that is not necessarily understood clearly by the management.
The management should support the need to refactor even if it does not bring clear added
value to an end user. But it brings value by not letting the codebase rot and removing technical debt. If you have
software with lots of accumulated technical debt, developing new features and maintaining the software is costly. Also,
the quality of the software is lower, which can manifest in several bugs and lowered customer satisfaction.

Below is a list of the most common [code smells](https://en.wikipedia.org/wiki/Code_smell) and refactoring techniques to resolve them:

| Code Smell                                 | Refactoring Solution                   |
|--------------------------------------------|----------------------------------------|
| Non-descriptive name                       | Rename                                 |
| Long method                                | Extract method                         |
| Large class                                | Extract class                          |
| Complex expression                         | Extract constant                       |
| Long switch-case or if/elif/else statement | Replace conditionals with polymorphism |
| Long parameter list                        | Introduce parameter object             |
| Shotgun surgery                            | Replace conditionals with polymorphism |
| Negated boolean condition                  | Invert if-statement                    |
| Anemic object                              | Creating rich object                   |

There are other refactoring techniques, but the ones explained here are the most relevant and valuable. You can
find other refactoring techniques in *Martin Fowler*'s book *Refactoring*. Some of the refactorings presented in that book
are pretty self-evident for experienced OOP practitioners; others are also handled in this book but scattered around and
described as part of different principles and patterns, and some refactorings are primarily for legacy code only.
You don't need them when writing new code with appropriate linter settings active. One example of such a refactoring is "Remove Assignments to Parameters".
You don't need that when writing new code because you should have a linting rule that disallows assignments to parameters.

### Rename

This is probably the single most used refactoring technique. You often don't get the names right on the first try
and need to do renaming. Modern IDEs offer tools that help rename things in the code: interfaces, classes,
functions, and variables. The IDE's renaming functionality is always better than the plain old
search-and-replace method. When using the search-and-replace method, you can accidentally rename something you do not want to be renamed or don't rename something that should have been renamed.

### Extract Method

This is probably the second most used refactoring technique. When you implement a public method of a class, the method
quickly grows in the number of code lines. A function should contain a maximum of 5-9 statements to keep it readable and understandable.
When a public method is too long, you should extract one or more private methods and call these private methods
from the public method. Every modern IDE has an *extract method* refactoring tool that allows you to extract
private methods easily. Select the code lines you want to extract to a new method and press the IDE's shortcut key
for the *extract method* functionality. Then, give a descriptive name for the extracted method, and you are
done. (An additional thing you can do is to organize the arguments of the extracted method in better order
before completing the extraction in the IDE). In some cases, the refactoring is not automatic. For example, if the code to be extracted contains a *return*, *break*,
or *continue* statement, that affects the execution flow of the function (causing multiple return points). To keep
your code refactorable, avoid using *break* and *continue* statements and have only a single return statement
at the end of the function.

### Extract Class

This refactoring technique is used to make a large class smaller. A large class contains several hundreds of
lines of code or tens of methods. To make a class smaller, you need to extract one or more behavioral classes from
it and use them in the original class. This refactoring technique allows you to use the *strategy pattern* described
in the previous chapter. Let's have a simple example with a `Bird` class, which we assume to be large:

```java
public class Bird {
  public void move() {
    // This method uses the below helper methods
  }

  public void makeSound() {
    // This method uses the below helper methods
  }

  // Possibly some other public methods ...

  private void moveHelper1() {
    // ...
  }

  // ...

  private void moveHelper4() {
    // ...
  }


  private void makeSoundHelper1() {
    // ...
  }

  // ...

  private void makeSoundHelper4() {
    // ...
  }
}
```

To make the above class smaller, we can extract two behavioral classes: `BirdMover` and `BirdSoundMaker`.
After refactoring, we have the following classes:

```java
public interface BirdMover {
  void move();
}


public class BirdMoverImpl implements BirdMover {
  public void move() {
    // Use the below helper methods ...
  }

  private void moveHelper1() {
    // ...
  }

  // ...

  private void moveHelper4() {
    // ...
  }
}


public interface BirdSoundMaker {
  void makeSound();
}


public class BirdSoundMakerImpl implements BirdSoundMaker {
  public void makeSound() {
    // Use the below helper methods ...
  }

  private void makeSoundHelper1() {
    // ...
  }

  // ...

  private void makeSoundHelper4() {
    // ...
  }
}


public class Bird {
  private final BirdMover mover;
  private final BirdSoundMaker soundMaker;

  public Bird(final BirdMover mover, final BirdSoundMaker soundMaker) {
    this.mover = mover;
    this.soundMaker = soundMaker;
  }

  public void move() {
    // Call mover.move()
  }

  public void makeSound() {
    // Call soundMaker.makeSound()
  }

  // Possibly some other public methods ...
}
```

The above solution allows us to use the *strategy pattern*. We can introduce new classes that implement the `BirdMover` and `BirdSoundMaker` protocols and supply them to the `Bird` class constructor.
We can now modify the behavior of the `Bird` class using the *open-closed principle*.

### Extract Constant

If you have a complex expression (boolean or numeric), assign the value of the expression to a constant.
The name of the constant conveys information about the expression. Below is a JavaScript example where we make the if-statements read better
by extracting expressions to constants:

```js
// ...

if (dataSourceSelectorIsOpen &&
    measureSelectorIsOpen &&
    dimensionSelectorIsOpen
) {
  dataSourceSelectorContentElem.style.height =
    `${0.2 * availableHeight}px`;

  measureSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;

  dimensionSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
} else if (!dataSourceSelectorIsOpen &&
           !measureSelectorIsOpen &&
           dimensionSelectorIsOpen
) {
    dimensionSelectorContentElem.style.height
      = `${availableHeight}px`;
}
```

Let's extract constants:

```js
// ...

const allSelectorsAreOpen = dataSourceSelectorIsOpen &&
                            measureSelectorIsOpen &&
                            dimensionSelectorIsOpen;

const onlyDimensionSelectorIsOpen =
    !dataSourceSelectorIsOpen &&
    !measureSelectorIsOpen &&
    dimensionSelectorIsOpen;

if (allSelectorsAreOpen) {
  dataSourceSelectorContentElem.style.height =
    `${0.2 * availableHeight}px`;

  measureSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;

  dimensionSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
} else if (onlyDimensionSelectorIsOpen) {
  dimensionSelectorContentElem.style.height =
    `${availableHeight}px`;
}
```

Below is an example in C++ where we return a boolean expression:


```cpp
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherFieldSchema
) const
{
  return m_type == otherFieldSchema->getType() &&
         m_name.substr(m_name.find_first_of('.') + 1U) ==
         otherFieldSchema->getName().substr(
          otherFieldSchema->getName().find_first_of('.') + 1U);
}
```

It can be challenging to understand what the boolean expression means.
We could improve the function by adding a comment: (We assume
that each field name has a root namespace that cannot contain a dot character)

```cpp
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherFieldSchema
) const
{
  // Field schemas are equal if field types are equal and
  // field names without the root namespace are equal
  return m_type == otherFieldSchema->getType() &&
         m_name.substr(m_name.find_first_of('.') + 1U) ==
         otherFieldSchema->getName().substr(
          otherFieldSchema->getName().find_first_of('.') + 1U);
}
```

But we should not write comments because comments are never 100% trustworthy.
It is possible that a comment and the related code are not in synchrony: someone has changed the function without updating the comment or modified only the comment but
did not change the function.
Let's refactor the above example by removing the comment and extracting multiple constants.
The below function is longer than the original, but it is, of course, more readable. If you look
at the last two statements of the method, you can understand in what case two field schemas
are equal. It should be the compiler's job to make the below longer version of the function as performant as the original
function.

```cpp
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherFieldSchema
) const
{
  const auto fieldNameWithoutRootNamespace =
    m_name.substr(m_name.find_first_of('.') + 1U);

  const auto otherFieldName = otherFieldSchema->getName();

  const auto otherFieldNameWithoutRootNamespace =
    otherFieldName.substr(otherFieldName.find_first_of('.') + 1U);

  const bool fieldTypesAndNamesWithoutRootNsAreEqual =
    m_type == otherFieldSchema->getType() &&
    fieldNameWithoutRootNamespace == otherFieldNameWithoutRootNamespace;

  return fieldTypesAndNamesWithoutRootNsAreEqual;
}
```

### Replace Conditionals with Polymorphism

Suppose you encounter a sizeable match-case statement or if/elif-structure in your code (not considering
code in factories). It means your software component does not have a proper object-oriented design.
You should replace the conditionals with polymorphism. When you introduce proper OOD
in your software component, you move the functionality from a match statement's case branches to different
classes that implement a particular interface. And similarly, you move the code from if and elif-statements
to different classes that implement a specific interface. This way, you can eliminate the match-case and if/elif-statements
and replace them with polymorphic method calls. Crafting proper OOD helps in creating a software component with classes
that have high cohesion. The functionality of the classes is no longer scattered around in the codebase.

Below is a TypeScript example of non-object-oriented design:

```ts
function doSomethingWith(chart: Chart) {
  if (chart.getType() === 'column') {
    // do this
  } else if (chart.getType() === 'pie') {
    // do that
  } else if (chart.getType() === 'geographic-map') {
    // do a third thing
  }
}
```

Let's replace the above conditionals with polymorphism:

```ts
interface Chart {
  doSomething(...): void;
}

class ColumnChart implements Chart {
  doSomething(...): void {
    // do this
  }
}

class PieChart implements Chart {
  doSomething(...): void {
    // do that
  }
}

class GeographicMapChart implements Chart {
  doSomething(...): void {
    // do a third thing
  }
}

function doSomethingWith(chart: Chart) {
  chart.doSomething();
}
```

Suppose you are implementing a data visualization application and have many places in your code where you check the chart type and need to introduce a new chart type.
It could mean you must add a new *case* or *elif* statement in many places in the code. This approach is very error-prone.
It is called *shotgun surgery* because you need to find all the places in the codebase where the code needs to be modified.
What you should do is conduct proper object-oriented design and introduce a new chart class containing the new functionality
instead of introducing that new functionality by modifying code in multiple places.

### Introduce Parameter Object

If you have more than 5-7 parameters for a function, you should introduce a parameter object to reduce
the number of parameters to keep the function signature more readable. Below is an example constructor
with too many parameters:

{title: "KafkaConsumer.java"}
```java
public class KafkaConsumer {
  public KafkaConsumer(
    final List<String> brokers,
    final List<String> topics,
    final List<String> extraConfigEntries,
    final boolean tlsIsUsed,
    final boolean certShouldBeVerified,
    final String caFilePathName,
    final String certFilePathName,
    final String keyFilePathName)
  {
    // ...
  }
}
```

Let's group the Transport Layer Security (TLS) related parameters to a parameter class named `TlsOptions`:

{title: "TlsOptions.java"}
```java
public class TlsOptions {
  public TlsOptions(
    final boolean tlsIsUsed,
    final boolean certShouldBeVerified,
    final String caFilePathName,
    final String certFilePathName,
    final String keyFilePathName
  ) {
    // ...
  }
}
```

Now we can modify the `KafkaConsumer` constructor to utilize the `TlsOptions` parameter class:

{title: "KafkaConsumer.java"}
```java
public class KafkaConsumer {
  public KafkaConsumer(
    final List<String> brokers,
    final List<String> topics,
    final List<String> extraConfigEntries,
    final TlsOptions tlsOptions
  ) {
    // ...
  }
}
```

### Invert If-Statement

This is a refactoring that a modern IDE can do for you.

Below is a Python example with a negated boolean expression in the if-statement condition.
Notice how difficult the boolean expression reads: `host_mount_folder is not None`. It is a double-negative statement
and thus can be difficult to read.

<div class="sourceCodeWithoutLabel">

```python
import os


def get_behave_test_folder(relative_test_folder = ""):
  host_mount_folder = os.environ.get("HOST_MOUNT_FOLDER")

  if host_mount_folder is not None:
    final_host_mount_folder = host_mount_folder
    if host_mount_folder.startswith("/mnt/c/"):
      final_host_mount_folder = host_mount_folder.replace("/mnt/c/", \
                                                          "/c/", 1)

    behave_test_folder = final_host_mount_folder + "/" + \
                         relative_test_folder
  else:
    behave_test_folder = os.getcwd()

  return behave_test_folder
```

Let's refactor the above code so that the if and else statements are inverted:

```
def get_behave_test_folder(relative_test_folder = ""):
  host_mount_folder = os.environ.get("HOST_MOUNT_FOLDER")

  if host_mount_folder is None:
    behave_test_folder = os.getcwd()
  else:
    final_host_mount_folder = host_mount_folder
    if host_mount_folder.startswith("/mnt/c/"):
      final_host_mount_folder = host_mount_folder.replace("/mnt/c/", \
                                                          "/c/", 1)
    behave_test_folder = final_host_mount_folder + "/" + \
                         relative_test_folder

  return behave_test_folder
```

Below is another example in C++:

```cpp
if (somePointer != nullptr)
{
  // Do thing 1
}
else
{
  // Do thing 2
}
```

We should not have a negation in the if-statement's condition. Let's refactor the above example:

```cpp
if (somePointer == nullptr)
{
  // Do thing 2
}
else
{
  // Do thing 1
}
```

### Creating Rich Object

An object can be a so-called [anemic object](https://en.wikipedia.org/wiki/Anemic_domain_model) with little or no behavior.
The object class might only contain attributes and getters and setters for them, making it a kind of data class only.
Sometimes, this is okay if there is no business
logic related to the object, but many times, there exists some business logic, but that logic is not implemented in the anemic object
class itself but in other places in the code. This kind of software "design" (a better term is lack of design) is deemed to be problematic
when you need to change the anemic object class. You might need to make changes to various unrelated places in the code. Making all these changes is manual and error-prone work.
Making those changes is called [shotgun surgery](https://en.wikipedia.org/wiki/Shotgun_surgery). What you should do is make an anemic object a rich object.
This is done by moving behavior from other classes to the anemic class, making it a rich class. A rich class typically has attributes and behavior but
it lacks getters and setters to enforce proper encapsulation of the object state.

Let's have an example of a anemic class:

```java
public class Rectangle {
  private float width;
  private float height;

  public Rectangle(final float width, final float height) {
    this.width = width;
    this.height = height;
  }

  public float getWidth() {
    return width;
  }


  public float getHeight() {
    return height;
  }

  public void setWidth(final float width) {
    this.width = width;
  }

  public void setHeight(final float height) {
    this.height = height;
  }
}


public class Drawer {
  // Possible other methods ...

  public void drawRectangle(final Rectangle rectangle) {
    // ...
  }
}


public class Calculator {
  // Possible other methods

  public float calcRectArea(final Rectangle rectangle) {
    // ...
  }

  public float calcRectPerimeter(final Rectangle rectangle) {
    // ...
  }
}

public class Sizer {
  // Possible other methods

  public void increaseRectWidth(
    final Rectangle rectangle,
    final float percentage
  ) {
    // ...
  }


 public void increaseRectHeight(
    final Rectangle rectangle,
    final float percentage
 ) {
   // ...
 }
}
```

What we should do is to make the `Rectangle` objects rich objects by moving functionality from various classes
into the `Rectangle class` and removing the getters and setters:

```java
public class Rectangle {
  private float width;
  private float height;

  public Rectangle(final float width, final float height) {
    this.width = width;
    this.height = height;
  }

  public void draw() {
    // Implement drawing here ...
  }

  public float calculateArea() {
    // Calculate area here ...
  }

  public float calculatePerimeter() {
    // Calculate perimeter here ...
  }

  public void increaseWidth(final float percentage) {
    // Increase width here ...
  }

  public void increaseHeight(final float percentage) {
    // Increase height here ...
  }
}
```

Let's imagine that the methods added to the `Rectangle` class are large, and the whole class becomes too large.
In that case, we can use the *bridge pattern* and refactor the classes as shown below. We still have a rich `Rectangle` class
with attached behaviour and we do not need any getters or setters because we are not passing the `self` to any outside
object of the `Rectangle` class.

```java
public interface Drawer {
  void drawRectangle(final float width, final float height);

  // Possible other methods ...
}


public interface Calculator {
  float calcRectArea(final float width, final float height);
  float calcRectPerimeter(final float width, final float height);

  // Possible other methods ...
}

public interface Sizer {
  float increase(final float length, final float percentage);

  // Possible other methods ...
}


public class Rectangle {
  private float width;
  private float height;
  private final Drawer drawer;
  private final Calculator calculator;
  private final Sizer sizer;

  public Rectangle(
    final float width,
    final float height,
    final Drawer drawer,
    final Calculator calculator,
    final Sizer sizer
  ) {
    this.width = width;
    this.height = height;
    this.drawer = drawer;
    this.calculator = calculator;
    this.sizer = sizer;
  }

  public void draw() {
    drawer.drawRectangle(width, height);
  }

  public float calculateArea() {
    return calculator.calcRectArea(width, height);
  }

  public float calculatePerimeter() {
    return calculator.calcRectPerimeter(width, height);
  }

  public void increaseWidth(final float percentage) {
    width = sizer.increase(width, percentage);
  }

  public void increaseHeight(final float percentage) {
    height = sizer.increase(height, percentage);
  }
}
```

You can see from the above code that we no longer need to perform *shotgun surgery* if we need to change the `Rectangle` class. For example, let's say that our rectangles should always have a height double the width. We can refactor the `Rectangle` class to the following:

```java
public class Rectangle {
  private float width;
  private float height;
  private final Drawer drawer;
  private final Calculator calculator;
  private final Sizer sizer;

  public Rectangle(
    final float width,
    final Drawer drawer,
    final Calculator calculator,
    final Sizer sizer
  ) {
    this.width = width;
    this.height = 2 * width;
    this.drawer = drawer;
    this.calculator = calculator;
    this.sizer = sizer;
  }

  public void draw() {
    drawer.drawRectangle(width, height);
  }

  public float calculateArea() {
    return calculator.calcRectArea(width, height);
  }

  public float calculatePerimeter() {
    return calculator.calcRectPerimeter(width, height);
  }

  public void increaseWidth(final float percentage) {
    width = sizer.increase(width, percentage);
    height = 2 * width;
  }

  public void increaseHeight(final float percentage) {
    height = sizer.increase(height, percentage);
    width = height / 2;
  }
}
```

## Static Code Analysis Principle

> ***Let the computer find bugs and issues in the code for you.***

Static code analysis tools find bugs and design-related issues on your behalf. Use multiple static code analysis tools to get the full benefit. Different tools might detect
different issues. Using static code analysis tools frees people's time in code reviews to focus on things that automation cannot tackle.

Below is a list of some common static code analysis tools for different languages:

- Java
    - Jetbrains IntelliJ IDEA IDE inspections
    - SonarLint
    - SonarQube/SonarCloud
- C++
    - Jetbrains CLion IDE inspections
    - Clang-Tidy
    - MISRA C++ 2008 guidelines
    - CppCheck
    - SonarLint
    - SonarQube/SonarCloud
- TypeScript
    - Jetbrains WebStorm IDE inspections
    - ESLint (+ various plugins, like TypeScript plugin)
    - SonarLint
    - SonarQube/SonarCloud

Infrastructure and deployment code should be treated the same way as source code. Remember to run static code analysis
tools on your infrastructure and deployment code, too. Several tools are available for analyzing infrastructure and deployment code, like _Checkcov_, which can be used for analyzing Terraform, Kubernetes, and Helm code. Helm tool contains a linting command
to analyze Helm chart files, and _Hadolint_ is a tool for analyzing _Dockerfiles_ statically.

### Common Static Code Analysis Issues

| Issue                                                                                        | Description/Solution                                                                                                                                                                                                                                |
|----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Chain of instance of checks                                                                  | This issue indicates a chain of conditionals in favor of object-oriented design. Use the _replace conditionals with polymorphism_ refactoring technique to solve this issue.                                                                        |
| Feature envy                                                                                 | Use the _don't ask, tell principle_ from the previous chapter to solve this issue.                                                                                                                                                                  |
| Use of concrete classes                                                                      | Use the _program against interfaces_ principle from the previous chapter to solve this issue.                                                                                                                                                       |
| Assignment to a function argument                                                            | Don't modify function arguments but introduce a new variable. You can avoid this issue in Java by declaring function parameters as _final_.                                                                                                         |
 | Commented-out code                                                                           | Remove the commented-out code. If you need that piece of code in the future, it is available in the version control system forever.                                                                                                                 |
| Const correctness                                                                            | Make variables and parameters const or final whenever possible to achieve immutability and avoid accidental modifications                                                                                                                           |
| Nested switch statement                                                                      | Use switch statements mainly only in factories. Do not nest them.                                                                                                                                                                                   |
 | Nested conditional expression                                                                | Conditional expression (?:) should not be nested because it greatly hinders the code readability.                                                                                                                                                   |
 | Overly complex boolean expression                                                            | Split the boolean expression into parts and introduce constants to store the parts and the final expression                                                                                                                                         |
 | Expression can be simplified                                                                 | This can be refactored automatically by the IDE.                                                                                                                                                                                                    |
 | Switch statement without default branch                                                      | Always introduce a default branch and throw an exception from there. Otherwise, when you are using a switch statement with an enum, you might encounter strange problems after adding a new enum value that is not handled by the switch statement. |
| Law of Demeter                                                                               | The object knows too much. It is coupled to the dependencies of another object, which creates additional coupling and makes code harder to change.                                                                                                  |
 | Reuse of local variable                                                                      | Instead of reusing a variable for a different purpose, introduce a new variable. That new variable can be named appropriately to describe its purpose.                                                                                              |
| Scope of variable is too broad                                                               | Introduce a variable only just before it is needed.                                                                                                                                                                                                 |
 | Protected field                                                                              | Subclasses can modify the protected state of the superclass without the superclass being able to control that. This is an indication of breaking the encapsulation and should be avoided.                                                           |
 | Breaking the encapsulation: Return of modifiable/mutable field                               | Use the _don't leak modifiable internal state outside an object principle_ from the previous chapter to solve this issue.                                                                                                                           |
 | Breaking the encapsulation: Assignment from a method parameter to a modifiable/mutable field | Use the _don't assign from a method parameter to a modifiable field principle_ from the previous chapter to solve this issue.                                                                                                                       |
 | Non-constant public field                                                                    | Anyone can modify a public field. This breaks the encapsulation and should be avoided.                                                                                                                                                              |
 | Overly broad catch-block                                                                     | This can indicate a wrong design. Don't catch the language's base exception class if you should only catch your application's base error class, for example. Read more about handling exceptions in the next section.                               |

## Error/Exception Handling Principle

Many languages like C++, Java, and JavaScript/TypeScript have an exception-handling mechanism that can
handle errors and exceptional situations. First of all, I want to make a clear distinction between these two words:

> ***An error can happen, and one should be prepared for it. An exception is something that should never happen.***

You define errors in your code and throw them in your functions. For example, if you try to write to
a file, you must be prepared for the error that the disk is full, or if you are reading a file, you must be prepared
for the error that the file does not exist (anymore).

Some errors are recoverable. You can delete files
from the disk to free up some space to write to a file. Or, in case a file is not found, you can give a "file not found" error to the user,
who can then retry the operation using
a different file name, for example.

You usually don't need to define your own exceptions in your application, but the system
throws built-in exceptions in *exceptional situations*, like when a programming error is encountered.
An exception can be thrown, for example, when memory is low, and memory
allocation cannot be performed, or when a programming error results in an array index out of bounds or
a null pointer access. When an exception is thrown, the program cannot continue executing
normally and might need to terminate. This is why many exceptions can be categorized as unrecoverable errors. In some cases,
it is possible to recover from exceptions. Suppose a web service encounters an exception while handling an HTTP request. In that case,
you can terminate the handling of the current request, return an error response to the client, and continue handling further
requests normally. It depends on the software component how it should handle exceptional situations. This is important
to consider when designing a new software component. You should define (and document) how the software component should handle exceptions.
Should it terminate the process or perhaps do something else?

Errors define situations where the execution of a function fails for some reason. Typical examples of errors are
a file not found error, an error in sending an HTTP request to a remote service, or a failure to parse a configuration
file. Suppose a function can throw an error. The function caller can decide how to handle the error depending on the error. With transient errors, like
a failing network request, the function caller can wait a while and call the function again. Or, the function caller
can use a default value. For example, if a function tries to
load a configuration file that does not exist, it can use some default configuration instead. In some cases,
the function caller cannot do anything but leave the error unhandled or catch the error but throw
another error at a higher level of abstraction. Suppose a function tries to load a configuration file, but the loading fails, and no
default configuration exists. In that case, the function cannot do anything but pass the error to its caller. Eventually,
this error bubbles up in the call stack, and the whole process is terminated due to the inability to
load the configuration. This is because the configuration is needed to run the application. Without configuration,
the application cannot do anything but exit.

When defining error classes, define a base error class for your software component. You can name the base error class according to the name of the software component.
For example, for the data exporter
microservice, you can define a `DataExporterError` (or `DataExporterServiceError`) base error class. For *common-utils-lib*,
you can define `CommonUtilsError` (or `CommonUtilsLibError`), and for *sales-item-service*, you can define `SalesItemServiceError`.
The popular Python [requests](https://requests.readthedocs.io/en/latest/) library implements this convention.
It defines a `requests.RequestException,` which is the base class for all other errors the library methods can raise.
Many other Python libraries also define a common base error class.

For each function that can throw an error, define a base error class
at the same abstraction level as the function. That error class should extend the software component's base error class. For example,
if you have a `parse(configStr)` method in the `ConfigParser` class, define a base error class for the function inside the class with the name `ParseError`,
i.e., `ConfigParser.ParseError`. If you have a `readFile` method in the `FileReader` class, define a base error class in the `FileReader` class
with the name `ReadFileError`, i.e., `FileReader.ReadFileError`. If all the methods in a class can throw the same error, it is enough to define
only one error at the class level. For example, if you have a `HttpClient` class where all methods like `get`, `post`, `put` etc., can throw
an error, you can only define a single `Error` error class in the `HttpClient` class.

Below is a Java example of errors defined for the data exporter microservice:

```java
// Base error class for the software component
public class DataExporterError extends RuntimeException {
  public DataExporterError(final Exception error) {
    super(error);
  }
}


public class FileReader {
  // Base error class for the 'readFile' method
  // Extends the base error class of the software component
  public static class ReadFileError extends DataExporterError {
    public ReadFileError(final Exception error) {
      super(error);
    }
  }

  void readFile(final String pathName) {
    // ...
    // throw new ReadFileError(...);
  }
}


public class ConfigParser {
  // Base error class for the 'parse' method
  // Extends the base error class of the software component
  public static class ParseError extends DataExporterError {
      public ParseError(final Exception error) {
        super(error);
      }
    }

  void parse(final String configStr) {
  // ...
  // throw new ParseError(...)
  }
}
```

Following the previous rules makes catching errors in the code easy because you can infer the error class
name from the called method name. In the below example, we can infer the `ReadFileError` error class name
from the `readFile` method name:

```java
try {
  final var fileContents = fileReader.readFile(...);
} catch (final FileReader.FileReadError error) {
  // Handle error
}
```

You can also catch all user-defined errors using the software component's base error class in the catch
clause. The below two examples have the same effect.

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final FileReader.FileReadError | ConfigParser.ParseError error) {
  // Handle error situation
}
```

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final DataExporterError error) {
  // Handle error situation
}
```

Don't catch the language's base exception class or some other too-generic exception class because that will catch, in addition
to all user-defined errors, exceptions, like null pointer exceptions, which is probably not what you want. So, do
not catch a too-generic exception class like this:

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final Exception exception) {
  // Do not use! Catches all exceptions
}
```

Also, do not catch the `Throwable` class in Java because it will also catch any fatal errors that are not meant to be caught:

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final Throwable throwable) {
  // Do not use! Catches everything including
  // all exceptions and fatal errors
}
```
</div>

Catch all exceptions only in special places in your code, like in the main function or the main loop, like the loop in a web service
processing HTTP requests or the main loop of a thread. Below is an example of correctly catching the language's base exception class in the main function.
When you catch an unrecoverable exception in the main function, log it and exit the process with an appropriate error code. When you catch an
unrecoverable error in a main loop, log it and continue the loop if possible.

```java
public static void main(final String[] args) {
  // ...

   try {
     application.run(...);
   } catch (final Exception exception) {
     logger.log(exception);
     System.exit(1);
   }
}
```

Using the above-described rules, you can make your code future-proof or forward-compatible so that adding new errors to be thrown from a function
in the future is possible. Let's say that you are using a `fetchConfig` function like this:

```java
try {
  final var configuration = configFetcher.fetchConfig(url);
} catch(final ConfigFetcher.FetchConfigError error) {
  // Handle error ...
}
```

Your code should still work if a new type of error is raised in the `fetchConfig` function. Let's say that the following new errors
could be thrown from the `fetchConfig` function:

- Malformed URL error
- Server not found error
- Connection timeout error

When classes for these new errors are implemented, they must extend the function's base error class, in this case, the `FetchConfigError` class.
Below are the error classes defined:

```java
public class ConfigFetcher {
  // Base error class for 'fetchConfig' method
  // Extends the base error class of the software component
  public static class FetchConfigError extends DataExporterError {
    public FetchConfigError(final Exception error) {
      super(error);
    }
  }

  // An additional error for 'fetchConfig' method
  // Extends the base error class of the method
  public static class MalformedUrlError extends FetchConfigError {
    public MalformedUrlError(final Exception error) {
      super(error);
    }
  }


  // An additional error for 'fetchConfig' method
  // Extends the base error class of the method
  public static class ServerNotFoundError extends FetchConfigError {
    public ServerNotFoundError(final Exception error) {
      super(error);
    }
  }

  // An additional error for 'fetch_config' method
  // Extends the base error class of the method
  public static class ConnectionTimeoutError extends FetchConfigError {
    public ConnectionTimeoutError(final Exception error) {
      super(error);
    }
  }

  public Config fetchConfig(final String url) {
    // ...
    // throw new MalformedUrlError(...)
    // throw new ServerNotFoundError(...)
    // throw new ConnectionTimeoutError(...)
  }
}
```

You can enhance your code at any time to handle different errors thrown from the `fetch_config` method differently.
For example, you might want to handle a `ConnectionTimeoutError` so that the function will wait a while and then retry the
operation because the error is usually transient:

```java
try {
  final var configuration = configFetcher.fetchConfig(url);
} catch (final ConfigFetcher.ConnectionTimeoutError error) {
  // Retry after a while
} catch (final ConfigFetcher.MalformedUrlError error) {
  // Inform caller that URL should be checked
} catch (final ConfigFetcher.ServerNotFoundError error) {
  // Inform caller that URL host/port cannot be reached
} catch (final ConfigFetcher.FetchConfigError error) {
  // Handle possible other error situations
  // This will catch any error that could be raised
  // in 'fetchConfig' method now and in the future
}
```

In the above examples, we handled thrown errors correctly, but you can easily forget to handle a thrown error.
This is because nothing in the function signature tells you whether the function can throw an error. The only way to find out
is to check the documentation (if available) or investigate the source code (if available). This is one of the biggest problems
regarding exception handling because you must know and remember that a function can throw an error, and you must remember to catch and handle errors.
You don't always want to handle an error immediately, but still, you must be aware that the error will bubble up in the call stack and should be
dealt with eventually somewhere in the code.

Below is an example extracted from the documentation of the popular Python *requests* library:

```python
import requests

r = requests.get('https://api.github.com/events')
r.json()
# [{'repository': {'open_issues': 0, 'url': 'https://github.com/...
```

Did you know that both `requests.get` and `r.json` can raise an error? Unfortunately, the above documentation extract does not include error handling at all.
If you copy-paste the above code sample directly into your production code, you forget to handle errors.
If you go to the API reference documentation of the *requests* library, you can find the documentation for the `get` method.
That documentation (when writing this book) does not tell that the method can raise an error. The documentation only
speaks about the method parameters, return value, and its type. Scrolling down the documentation page, you will find
a section about exceptions. But what if you don't scroll down? You might think that the method does not raise an
error. The `get` method documentation should be corrected to tell that the method can raise an error and contain a link to the section where
possible errors are described.

The above-described problems can be mitigated, at least on some level, when practicing *test-driven development* (TDD).
TDD will be described in the next chapter, which covers testing-related principles. In TDD, you define the tests before
the implementation, forcing you to think about error scenarios and make tests for them. When you have tests
for error scenarios, leaving those scenarios unhandled in the actual implementation code is impossible.

One great solution to the problem that error handling might be forgotten is to make throwing errors more explicit:

> ***Use a 'try' prefix in a function name if the function can throw an error.***

This is a straightforward rule. If a function can throw an error, name the function so that its name starts with `try`.
This makes it clear to every caller that the function can throw an error, and the caller should be prepared
for that. For the caller of the function, there are three alternatives to deal with a thrown error:

1) Catch the base error class of the called function (or software component) and handle the error, e.g., catch `DataFetcher.FetchDataError` if you are calling a method named `tryFetchData` in a class named `DataFetcher`.
2) Catch the base error class of the called function (or software component) and throw a new error on a higher level of abstraction. You must also name the calling function with a `try` prefix.
3) Don't catch errors. Let them propagate upwards in the call stack. You must also name the calling function with a `try` prefix.

Here is an example of alternative 1:

```java
public class ConfigFetcher {
  public Configuration fetchConfig(final String configUrl) {
    try {
      final var configDataStr = dataFetcher.tryFetchData(configUrl);
      return configParser.tryParse(configDataStr);
    } catch (final DataFetcher.FetchDataError | ConfigParser.ParseError error) {
      // You could also catch DataFetchError and
      // ConfigParseError in different catch clauses
      // if their handling differs
      // You could also catch the base error class DataExporterError
      // of the software component
    }
  }
}
```

And here is an example of alternative 2:

```java
public class ConfigFetcher {
  public static class FetchConfigError extends DataExporterError {
    public FetchConfigError(final Exception error) {
      super(error);
    }
  }

  public Configuration tryFetchConfig(final String configUrl) {
    try {
      final var configDataStr = dataFetcher.tryFetchData(configUrl);
      return configParser.tryParse(configDataStr);
    } catch (final DataFetcher.FetchDataError | ConfigParser.ParseError error) {
      // Error on higher level of abstraction is thrown
      // This function must be named with the 'try' prefix
      // to indicate that it can throw
      throw new FetchConfigError(...);
    }
  }
}
```

And here is an example of alternative 3:

```python
from Config import Config


class ConfigFetcher:
    def try_fetch_config(self, url: str) -> Config:
        # No try-except, all raised errors from both try_fetch_data
        # and try_parse method calls propagate
        # to the caller and
        # this function must be named with the 'try' prefix
        # to indicate that it can raise an error
        config_str = self.__data_fetcher.try_fetch_data(url)
        return self.__config_parser.try_parse(config_str)
```

```python
from DataExporterError import DataExporterError


class DataExporter:
    def initialize(self) -> None:
        try:
            config = self.__config_fetcher.try_fetch_config(url)
        except DataExporterError as error:
            # In this case you must catch the base error class of
            # the software component (DataExporterError), because
            # you don't know what errors try_fetch_config can
            # raise, because no FetchConfigError class
            # has been defined in the ConfigFetcher class
```

If we go back to the *requests* library usage example, the error-raising methods `requests.get` and `Response.json`
could be renamed to `requests.try_get` and `Response.try_parse_json`. That would make the earlier example look like
the following:

```python
import requests

r = requests.try_get('https://api.github.com/events')
r.try_parse_json()
# [{'repository': {'open_issues': 0, 'url': 'https://github.com/...
```

Now, we can see that the two methods can raise an error. It is easier to remember to put them inside a try/except-block:

```python
import requests

try:
    r = requests.try_get('https://api.github.com/events')
    r.try_parse_json()
    # [{'repository': {'open_issues': 0, 'url': 'https://github.com/...
except ...
    # ...
```

To make the try-prefix convention even better, a linting rule that enforces the correct naming of error-raising functions could be developed.
The rule should force the function name to have a *try* prefix if the function raises or propagates errors. A function propagates errors
when it calls an error-raising (try-prefixed) method outside a try-except block.

You can also create a library that has try-prefixed functions that wrap error-raising functions that don't follow the try-prefix rule:

```python
import json


class JsonParser:
    class ParseError(Exception):
        pass

    @staticmethod
    def try_parse(json_string: str, **kwargs):
        try:
            return json.loads(json_string, **kwargs)
        except json.JSONDecodeError as error:
            raise JsonParser.ParseError(error)
```

Now, if you use the `JsonParser`'s `try_parse` method, you can easily infer the class name of the possibly raised errors without the
need to consult any documentation.

When using a web framework, the framework usually provides an error-handling mechanism. The framework catches all possible errors and exceptions when
processing a request and maps them to HTTP responses with HTTP status codes indicating a failure. Typically, the default status code is 500 *Internal Server Error*. When you utilize the web framework's error-handling mechanism,
there is no significant benefit in naming error-raising functions with the try-prefix because it won't be problematic if you forget to
catch an error. So, you can opt out of the try-prefix rule. Many times, this is what you want to do: pass the error to the web framework's error handler. Usually,
you provide your own error handler instead of using the default one, so you get responses in the format you want. We will discuss API error handling again in the *API design principles* chapter.

It is usually a good practice to document the error handling mechanism used in the software component's documentation.

The best way to avoid forgetting to handle errors is to practice rigorous *test-driven development* (TDD) described
in the next chapter. Another great way to not forget to handle errors is to walk through the code line by line and check
if the particular line can produce an error. If it can produce an error, what kind of error, and are there multiple
errors the line can produce? Let's have an example with the following code (we focus only on possible
errors, not what the function does):

```python
from typing import Any

import requests
from jwt import PyJWKClient, decode

class JwtAuthorizer:
    # ...

    def __try_get_jwt_claims(
            self, auth_header: str | None
        ) -> dict[str, Any]:
            if not self.__jwks_client:
                oidc_config_response = requests.get(self.__oidc_config_url)
                oidc_config = oidc_config_response.json()
                self.__jwks_client = PyJWKClient(oidc_config['jwks_uri'])

            jwt = auth_header.split('Bearer ')[1] if auth_header else ''
            signing_key = self.__jwks_client.get_signing_key_from_jwt(jwt)
            jwt_claims = decode(jwt, signing_key.key, algorithms=['RS256'])
            return jwt_claims
```

The code on the first line cannot produce an error. On the second line, the `requests.get` method can raise an
error on connection failure, for example. Can it produce other errors? It can produce the following errors:

- Malformed URL (`requests.URLRequired`)
- Connection error (`requests.ConnectionError`)
- Connection timeout (`requests.ConnectTimeout`)
- Read timeout (`requests.ReadTimeout`)

It can also produce an error response, e.g., an internal server error.
Our code does not handle that currently, which is why we should add the following line after the `requests.get` method call:
`oidc_config_response.raise_for_status()`, which will raise an `HttpError` if the response status code is >= 400. The third line can raise a `JSONDecodeError` if the response is not valid JSON. The fourth line can raise a `KeyError` because it is possible that the key `jwks_uri` does not exist in the response JSON. The fifth line can raise an `IndexError` because the list returned
by the `split` does not necessarily have an element at index one. Also, the sixth line can raise an error when
the JWKS client cannot connect to the IAM system or the JWT is invalid. The second last line can raise an `InvalidTokenError` when the JWT is invalid.
In summary, all the lines in the above code can produce at least one kind of error except the first and last lines.

Let's modify the code to implement error handling instead of passing all possible errors and exceptions to the caller:

```python
from typing import Any

import requests
from jwt import PyJWKClient, PyJWKClientError, decode
from jwt.exceptions import InvalidTokenError


class JwtAuthorizer:
    class GetJwtClaimsError(Exception):
        pass

    def __try_get_jwt_claims(
        self, auth_header: str | None
    ) -> dict[str, Any]:
        try:
            if not self.__jwks_client:
                oidc_config_response = requests.get(self.__oidc_config_url)
                oidc_config_response.raise_for_status()
                oidc_config = oidc_config_response.json()
                self.__jwks_client = PyJWKClient(oidc_config['jwks_uri'])

            jwt = auth_header.split('Bearer ')[1] if auth_header else ''
            signing_key = self.__jwks_client.get_signing_key_from_jwt(jwt)
            jwt_claims = decode(jwt, signing_key.key, algorithms=['RS256'])
            return jwt_claims
        except (
            # RequestException is the base error for all errors
            # in the requests library
            requests.RequestException,
            KeyError,
            IndexError,
            PyJWKClientError,
            # Base error when decode() fails on a token
            InvalidTokenError,
        ) as error:
            raise self.GetJwtClaimsError(error)
```

Make yourself a habit of walking through the code of a function line by line once you think it is ready to find out if you have accidentally missed handling some error.

### Returning Errors

As an alternative to raising errors, it is possible to
communicate erroneous behavior to the function caller using a return value. Using an exception-handling mechanism
provides some advantages over returning errors. When a function can return an error, you must always check
for the error right after the function call. This can cause the code to contain nested if-statements, which hinders code readability.
The exception-handling mechanism allows you to propagate an error
to a higher level in the call stack. You can also execute multiple function calls that can fail inside
a single `try` block and provide a single error handler in the `except` block.

#### Returning Failure Indicator

You can return a failure indicator from a failable function when the function does not need to return any additional value.
It is enough to return a failure indicator from the function when there is no need to return any specific error code or message.
This can be because there is only one reason the function can fail, or function callers are not interested in error details.
To return a failure indicator, return a boolean value from the function: *True* means a successful operation, and *False* indicates a failure:

```python
def perform_task(...) -> bool:
    # Perform the task and set the value of
    # the 'task_was_performed' variable

    return task_was_performed
```

#### Returning an Optional Value

Suppose a function should return a value, but the function call can fail, and there is precisely one cause
why the function call can fail. In this case,
return an optional value from the function. In the below example, getting a value from the cache can only fail when
no value for a specific key is stored in the cache. We don't need to return any error code or message.

```Python
from typing import Protocol, TypeVar

TKey = TypeVar('TKey')
TValue = TypeVar('TValue')


class Cache(Protocol[TKey, TValue]):
    def add(self, key: TKey, value: TValue) -> None:
        pass

    def get(self, key: TKey) -> TValue | None:
        pass
```

Or, if you want to use a more functional approach, return an `Optional` object. (The `Optional` class was defined
in the previous chapter)

```python
from typing import Protocol, TypeVar

from Optional import Optional

TKey = TypeVar('TKey')
TValue = TypeVar('TValue')


class Cache(Protocol[TKey, TValue]):
    def add(self, key: TKey, value: TValue) -> None:
        pass

    def get(self, key: TKey) -> Optional[TValue]:
        pass
```

#### Returning an Error Object

When you need to provide details about an error to the function caller, you can return an error object from the function:

```python
from dataclasses import dataclass


@dataclass
class BackendError:
    http_status_code: int
    error_code: int
    message: str
```

If a function does not return any value but can produce an error, you can return either an error object or
*None*:

```python
from typing import Awaitable, TypeVar

from BackendError import BackendError
from Entity import Entity

T = TypeVar('T', bound=Entity)


class DataStore:
    async def update_entity(
        self,
        id_: int,
        entity: T
    ) -> Awaitable[BackendError | None]:
        # ...
```

Alternatively, return an optional error, as shown below. (The `Optional` class was defined
in the previous chapter)

```python
from typing import Awaitable, TypeError

from BackendError import BackendError
from Entity import Entity
from Optional import Optional

T = TypeVar('T', bound=Entity)


class DataStore:
    async def update*entity(
        self,
        id*: int,
        entity: T
    ) -> Awaitable[Optional[BackendError]]:
        # ...
```

Suppose a function needs to return a value or an error. In that case, you can use a 2-tuple (i.e., a pair) type, where
the first value in the tuple is the actual value or *None* in case of an error and the second value
in the tuple is an error object or *None* value in case of a successful operation. Below is an example.

```python
from typing import Awaitable, TypeVar, Union

from BackendError import BackendError
from Entity import Entity

T = TypeVar('T', bound=Entity)


class DataStore:
    async def create_entity(
        self,
        entity: T
    ) ->  Awaitable[Union[(T, None), (None, BackendError)]]:
        # ...
```

If we want to make our method more functional, we should return an `Either` type from it, but Python does not have that.
Either type contains one of two values, either a left value or a right value. The `Either` type can be defined as follows.
(The `Optional` class was defined in the previous chapter).

```python
from collections.abc import Callable
from typing import Any, TypeVar, Generic

from Optional import Optional

TLeft = TypeVar('TLeft')
TRight = TypeVar('TRight')
T = TypeVar('T')
U = TypeVar('U')


class PrivateConstructor(type):
    def __call__(
        cls: type[T],
        *args: tuple[Any, ...],
        **kwargs: dict[str, Any]
     ):
        raise TypeError('Constructor is private')

    def _create(
        cls: type[T],
        *args: tuple[Any, ...],
        **kwargs: dict[str, Any]
    ) -> T:
        return super().__call__(*args, **kwargs)


class Either(Generic[TLeft, TRight], metaclass=PrivateConstructor):
    def __init__(
        self,
        maybe_left_value: Optional[TLeft],
        maybe_right_value: Optional[TRight]
    ):
        self.__maybe_left_value = maybe_left_value
        self.__maybe_right_value = maybe_right_value

    @classmethod
    def with_left(cls, value: TLeft) -> 'Either[TLeft, TRight]':
        return cls._create(Optional.of(value), Optional.empty())

    @classmethod
    def with_right(cls, value: TRight) -> 'Either[TLeft, TRight]':
        return cls._create(Optional.empty(), Optional.of(value))

    def has_left_value(self) -> bool:
        return self.__maybe_left_value.is_present()

    def has_right_value(self) -> bool:
            return self.__maybe_right_value.is_present()

    def map_left(
        self,
        to_value: Callable[[TLeft], U]
    ) -> 'Either[U, TRight]':
        return Either._create(
            self.__maybe_left_value.map(to_value),
            self.__maybe_right_value
        )

    def map_right(
        self,
        to_value: Callable[[TRight], U]
    ) -> 'Either[TLeft, U]':
        return Either._create(
            self.__maybe_left_value,
            self.__maybe_right_value.map(to_value)
        )

    def map(
        self,
        left_to_value: Callable[[TLeft], U],
        right_to_value: Callable[[TRight], U]
    ) -> U:
        return self.__maybe_left_value.map(left_to_value).or_else_get(
            lambda: self.__maybe_right_value.map(right_to_value).try_get()
        )

    def apply(
        self,
        consume_left_value: Callable[[TLeft], None],
        consume_right_value: Callable[[TRight], None]
    ) -> None:
        self.__maybe_left_value.if_present(consume_left_value)
        self.__maybe_right_value.if_present(consume_right_value)
```

Below are some examples of how to use the `Either` class:

```python
class Error(Exception):
    pass


int_or_error: Either[int, Error] = Either.with_left(3)
int_or_error2: Either[int, Error] = Either.with_right(Error())

print(int_or_error.has_left_value()) # Prints True
print(int_or_error2.has_right_value()) # Prints True
print(
    int_or_error.map_left(lambda number: number * 2).has_left_value()
)
# Prints True

print(int_or_error.map(lambda number: number * 2, lambda error: 0))
# Prints 6

print(int_or_error2.map(lambda number: number * 2, lambda error: 0))
# Prints 0
```

Now, we can use the new `Either` type and rewrite the example as follows:

```python
from typing import Awaitable, TypeVar

from BackendError import BackendError
from Entity import Entity

T = TypeVar('T', bound=Entity)


class DataStore:
    async def create_entity(
        self,
        entity: T
    ) ->  Awaitable[Either[T, BackendError]]:
        # ...
```

#### Adapt to Wanted Error Handling Mechanism

You can adapt to a desired error-handling mechanism by creating an adapter class. For example, if a library has an error-raising method,
you can create an adapter class with a method returning an optional value. The below `Url` class has a `try_create_url`
factory method that can raise an error:

```python
class Url:
    # ...

    class CreateUrlError(Exception):
        pass

    @classmethod
    def try_create_url(
        cls,
        scheme: str,
        host: str,
        port: int,
        path: str,
        query: str
    ) -> 'Url':
        # ...
        # Potentially raise a CreateUrlError here ...
```

We can create a `UrlFactory` adapter class with a non-error-raising method, `create_url`.

```python
from Url import Url


class UrlFactory:
    def create_url(
        self,
        scheme: str,
        host: str,
        port: int,
        path: str,
        query: str
    ) -> Url | None:
        try:
            return Url.try_create_url(scheme, host, port, path, query)
        except Url.CreateUrlError:
            return None
```

If the code using the `UrlFactory` is interested in the error details,
we can also create a method that does not raise an error but returns either a value or an error:

```python
from typing import Union

from Url import Url


class UrlFactory:
    def create_url_or_error(
        self,
        scheme: str,
        host: str,
        port: int,
        path: str,
        query: str
    ) -> Union[(Url, None), (None, Url.CreateUrlError)]:
        try:
            return (
                Url.try_create_url(scheme, host, port, path, query),
                None,
            )
        except Url.CreateUrlError as error:
            return None, error
```

#### Functional Exception Handling

The below `Failable` class can be used in functional error handling. A `Failable` object represents either
a value of type `T` or an instance of the `Exception` class, i.e., `Failable[T]` is the same as `Either[T, Exception]`

```python
from collections.abc import Callable
from typing import Any, Generic, TypeVar

from Either import Either

T = TypeVar('T')


class PrivateConstructor(type):
    def __call__(
        cls: type[T],
        *args: tuple[Any, ...],
        **kwargs: dict[str, Any]
     ):
        raise TypeError('Constructor is private')

    def _create(
        cls: type[T],
        *args: tuple[Any, ...],
        **kwargs: dict[str, Any]
    ) -> T:
        return super().__call__(*args, **kwargs)


TError = TypeVar('TError', bound=Exception)
U = TypeVar('U')


class Failable(Generic[T], metaclass=PrivateConstructor):
    def __init__(self, value_or_error: Either[T, Exception]):
        self.__value_or_error = value_or_error

    @classmethod
    def with_value(cls, value: T) -> 'Failable[T]':
        return cls._create(Either.with_left(value))

    @classmethod
    def with_error(cls, error: Exception) -> 'Failable[T]':
        return cls._create(Either.with_right(error))

    def or_raise(self, error_cls: type[TError]) -> T:
        return self.__value_or_error.map(
            lambda value: value,
            lambda error: self.__raise(error_cls(error))
        )

    def or_else(self, other_value: T) -> T:
        return self.__value_or_error.map(
            lambda value: value,
            lambda error: other_value
        )

    def map_value(
        self,
        to_value: Callable[[T], U]
    ) -> 'Failable[U]':
        return Failable._create(self.__value_or_error.map_left(to_value))

    def map_error(
        self,
        to_error: Callable[[Exception], Exception]
    ) -> 'Failable[T]':
        if self.__value_or_error.has_left_value():
            error = to_error(Exception())
            return Failable.with_error(error)
        else:
            return Failable._create(
                self.__value_or_error.map_right(to_error)
            )

    def __raise(self, error: Exception) -> None:
            raise error
```

In the below example, the `read_config` method returns a `Failable[Configuration]`. The `try_initialize` method either obtains an instance of
`Configuration` or raises an error of type `Application.InitializeError`.

```python
from DataExporterError import DataExporterError


class Application:
    # ...

    class InitializeError(DataExporterError):
        pass

    def try_initialize(self) -> None:
        configuration = self.__config_reader \
            .read_config(...) \
            .or_raise(self.InitializeError)
```

The benefit of the above functional approach is that it is shorter than an entire try-catch block. The above functional approach is also as understandable as a try-catch block.
Remember that one should write the shortest, most understandable code. When a method returns a `Failable` instance, you don't have to name the method
with the *try* prefix because the method does not raise an error. The call to the `or_raise` method on `Failable` converts the functional code back to imperative.

You can also use other methods of the `Failable` class. For example, a default value can be returned with the `or_else` method:

```try
from DefaultConfig import DefaultConfig


class Application:
    # ...

    def initialize(self) -> None:
        configuration = self.__config_reader.read_config(...).or_else(
            DefaultConfig()
        )
```

You can also transform multiple imperative error-raising statements into functional, failable statements. For example, instead of writing:

```python
from DataExporterError import DataExporterError


class Application:
    # ...

    class InitializeError(DataExporterError):
        pass

    def try_initialize(self) -> None:
        try:
            config_json = self.__data_fetcher.try_fetch_data(
                self.__config_url
            )

            configuration = self.__config_parser.try_parse(config_json)
        except DataExporterError as error:
            raise self.InitializeError(error)
```

You can write:

```python
from DataExporterError import DataExporterError


class Application:
    # ...

    class InitializeError(DataExporterError):
        pass

    def try_initialize(self) -> None:
        configuration = (
           self.__data_fetcher.fetch_data(self.__config_url)
           .map_value(self.__config_parser.parse)
           .or_raise(self.InitializeError)
       )
```

The above functional code is shorter than the same imperative code, but it is slightly less readable, for which reason
you might want to use the imperative approach instead of the functional approach.

It can be error-prone to use error-raising imperative code together with functional programming constructs.
For example, let's assume we have the below code that reads and parses multiple configuration files to
a single configuration object using a functional programming construct `reduce`. We have named the config reading function
`try_read_config` with the try-prefix because it can raise an error. When we use the `reduce` function, we must remember to surround it
with a try-except block because the `reduce` function will call the `try_read_config` function that can throw.

```python
import json
from functools import reduce
from typing import Any


def try_read_config(
    accumulated_config: dict[str, Any],
    config_file_path_name: str
):
    with open(config_file_path_name) as config_file:
        config_json = config_file.read()

    config = json.loads(config_json)
    return accumulated_config | config


def get_config(config_file_path_names: list[str]) -> dict[str, Any]:
    try:
        return reduce(try_read_config, config_file_path_names, {})
    except:
        # ...
```

We could turn the above example more functional by making the `get_config` function return a `Failable` instance:

```python
import json
from functools import reduce
from typing import Any

from Failable import Failable


def to_config_or_error(
    accum_config_or_error: Failable[dict[str, Any]],
    config_file_path_name: str
) -> Failable[dict[str, Any]]:
    try:
       with open(config_file_path_name) as config_file:
               config_json = config_file.read()

       config = json.loads(config_json)

       return accum_config_or_error.map_value(
            lambda accum_config: accum_config | config
        )
    except (OSError, json.JSONDecodeError) as error:
        return accum_config_or_error.map_error(
            lambda accum_error: RuntimeError(
                f'{str(accum_error)}\n{config_file_path_name}: {str(error)}'
            )
        )


def get_config(
    config_file_path_names: list[str]
) -> Failable[dict[str, Any]]:
    return reduce(
        to_config_or_error,
        config_file_path_names,
        Failable.with_value({})
    )
```

If we have a *config1.json* file with the following contents:

```json
{
    "foo": 1,
    "bar": 2
}
```

and we have a *config2.json* file with the following contents:

```json
{
    "xyz": 3
}
```

Then, we can run the following code:

```python
config_file_path_names = ['config1.json', 'config2.json']
maybeConfig = get_config(config_file_path_names)
print(maybeConfig.or_raise(RuntimeError))
# Prints {'foo': 1, 'bar': 2, 'xyz': 3}
```

Let's introduce an error (a missing comma after the first property) in the *config1.json* file:

```json
{
    "foo": 1
    "bar": 2
}
```

Let's also try to provide a non-existing configuration file *config3.json*:

```python
config_file_path_names = ['config1.json', 'config3.json']
maybeConfig = get_config(config_file_path_names)
print(maybeConfig.or_raise(RuntimeError))
# Raises a RuntimeError with the following message:
# config1.json: Expecting ',' delimiter: line 3 column 3 (char 16)
# config3.json: [Errno 2] No such file or directory: 'config3.json'
```

## Avoid Off-By-One Errors Principle

Off-by-one errors usually result from the fact that collections in programming languages are indexed with
zero-based indexes. Zero-based indexing is unnatural for human beings but excellent for computers. However, programming languages
should be designed with humans in mind. People never speak about getting the zeroth value of an array.
We speak of getting the first value in the array. As the null value was called a
billion-dollar mistake, I would call the zero-based indexing another billion-dollar mistake. Let's hope
that someday we get a programming language with one-based indexing! But then we must unlearn the zero-based indexing habit... And that's another problem!

In some languages, you can create for-loops with a loop counter.
Below are two examples of programming errors in JavaScript that are easy to make if you are not careful enough:

```js
for (let index = 0; index <= values.length; index++) {
  // ...
}

for (let index = 0; index < values.length - 1; index++) {
  // ...
}
```

In the first example, there should be '&lt;' instead of '&lt;=', and in the latter example, there should
be '&lt;=' instead of '&lt;'. Fortunately, the above mistakes can be avoided in Python:

```python
for value in values:
  # ...
```

In Python's `range` function, you must remember it starts from zero, and the end of the range is exclusive.
You will have an off-by-one error if you assume the start to be one or
the end of the range is inclusive. The off-by-one errors are caused by the fact that, given a range, people assume it is inclusive at both ends by default. So, a `range(6)` gives values from 0 to 5, not from 1 to 6. And `range(1, 6)`
gives values from 1 to 5, not from 1 to 6. The same thing is with slices, e.g. `values[:6]` starts from index 0 and
ends at index 5. If you want a slice that is all but the last item, you can use negative indexing: `values[:-1]` gives values except the last one. Using -1 is much safer than using `values[:len(values) - 1]`, which might produce
an off-by-one error if you forget the -1. And similarly using `values[:-2]` is less error-prone than using `values[:len(values) - 2]`.
You can also use negative indexing, e.g., to get the last value with `values[-1]` instead of `values[len(values) - 1]`.
A negative index is a one-based index starting from the end of a list.

Additionally, unit tests are your friend when trying to spot off-by-one errors. So remember to write unit tests for the edge cases, too.

## Be Critical When Googling or Using Generative AI Principle

> ***You should always analyze code taken from the web to ensure it meets the criteria for production code. Don't let the AI be the master, but an apprentice.***

We all have done it, and we have done it hundreds of times: googled for answers.
Usually, you find good resources by googling, but the problem often is that examples
in the Google results are not necessarily production quality. One specific thing missing in them is error
handling. If you copy and paste code from a website, it is possible that errors are not handled
appropriately. You should always analyze the copy-pasted code to see if error handling needs to be added.

When you provide answers for other people, try to make the code as production-like as possible.
In [Stack Overflow](https://stackoverflow.com/), you find the most up-voted answer right below the question. If the answer is missing error handling,
you can comment on that and let the author improve their answer. You can also up-vote an
answer that seems the most production-ready. The most up-voted answers tend to be pretty old. For this reason, it is
useful to scroll down to see if a more modern solution fits your needs better. You can also up-vote that more modern
solution to make it eventually rank higher in the list of answers.

Regarding open-source libraries, the first examples in their documentation can describe only the "happy path" usage scenario,
and error handling is described only in later parts of the documentation.
This can cause problems if you copy-paste code from the "happy path" example and forget to add error handling.
For this reason, open-source library authors should give production-quality examples early in the documentation.

Regarding generative AI, e.g., ChatGPT, I have a couple of experiences. I asked ChatGPT to generate simple Django code.
The generated code was about 95% correct, but it did not work. The problem was that ChatGPT forgot to provide code
for generating the database tables (makemigrations, migrate). If you are inexperienced with the Django framework, that
problem might be challenging to solve. In that case, continue the discussion with ChatGPT and ask it to solve the problem for you.

My other experiment with ChatGPT was to generate GraphQL server code using the *Ariadne* library.
The ChatGPT-generated code was for an old version of Ariadne and did not work correctly with a newer version of the
Ariadne library. (Notice that the data used to train ChatGPT contains more older than newer data. ChatGPT could not
prioritize the less and newer data over the older and more data.) It also generated some lines of code in the wrong order, which made the GraphQL API not work at all.
It took quite a lot of debugging for such a small program to find out what was wrong:
The executable schema was created before the query resolver. It should have been created only after defining the
resolver.

You should familiarize yourself with the AI-generated code when using ChatGPT or other generative AI tools. Otherwise, you
don't know what your program is doing, and if the AI-generated code contains bug(s), those will be hard to find
because you don't clearly understand what the code is actually doing. Don't let the AI be the master, but an apprentice.

The best way to prevent bugs related to code taken from the web is to practice *test-driven development* (TDD). TDD is better described
in the next chapter. The idea behind TDD is to specify the function first and write unit test cases for different
scenarios: edge/corner cases, error scenarios, and security scenarios. For example, let's say you are new
to Python and google for a code snippet to perform an HTTP request to an API endpoint.
You copy-paste the code into your function. Now, error scenarios are not handled. What you should do is practice TDD and write unit test cases for different scenarios, like, what if the remote server cannot be
contacted or the contact results in timeout, or what if the remote server responds with an error (an HTTP response with
a status code greater than or equal to 400). What if you need to parse the result from the API (e.g., parse JSON), and it fails?
Once you have written a unit test case for all those scenarios, you can be sure that error handling in the function
implementation is not forgotten.

## Make One Change At A Time Principle

> ***Don't try to make multiple distinct changes at the same time.***

If you try to make multiple unrelated changes simultaneously, you are focusing on too many things, and you are more likely to introduce a bug or bugs. Don't try to implement two distinct features at the same time. Don't try to
make two distinct refactorings at the same time. Don't try to implement a new feature and do refactoring simultaneously.
Try to make a single change as small and isolated as possible. I have violated this principle so many times. I have thought,
okay, this is a small change I can do together with this other change. But later, I realized that the changes were not so
small after all and that I had created some bugs. I didn't know which of the many changes caused the bug. That made the bug hunting more difficult than it should have been.
So, resist the urge to make multiple distinct changes simultaneously. Have all changes that need to be made as separate user stories in the team backlog or list small changes to be done in a TODO.MD file so that they are not forgotten.

If you need to implement a new feature, analyze if you should refactor the code first to make the feature implementation
easier. If the refactoring is not necessary for the feature and the feature is important, you can implement the feature first and refactor the code later.
If you gain benefit by refactoring first and the feature is not time-critical, refactor first and only after that implement the feature.

## Choosing Right 3rd Party Component Principle

When choosing the right 3rd party component, you should take the following into account:

- It provides the needed functionality
- If you are looking for an open-source component, check that the license is appropriate, e.g., without a viral effect (GPL)
- Prefer a well-established component over a brand new component because the new component may have bugs, and there is a smaller community that can offer you support.
  You shouldn't determine a well-established component by the number of GitHub stars only. Check the component download statistics from the package manager.
- Prefer a component that has a higher number of contributors because you can have your reported bugs corrected faster and also new features
  implemented faster.
- Ensure that dependencies are up-to-date. It is a red flag if the component has its dependencies updated like several years ago

## Use Appropriate Data Structure Principle

Next, the main built-in Python data structures with their use cases will be presented.

### List

> *Use a list when you need an ordered collection or should be able to store the same item multiple times.*

The implementation of a Python list is similar to C++'s `std::vector` or the `ArrayList` class in Java. Lists are mutable
and can contain duplicate elements. Each element can be accessed by its index in a performant way. If you need to add or remove
elements at the beginning of the list, that is not a cheap operation because all existing elements in the list must be
moved by one index to the right or left. Similarly, if you add an element to the end of a list and the allocated space for
the list is full, new space for the list must be allocated, and the list elements must be copied to the newly allocated space.

### Dictionary

> *Use a dictionary when you need quick access to a value by a key.*

Python dictionary is similar to a `HashMap` in Java. Accessing a value by its key is always a cheap operation.
You can iterate over a dictionary using one of the following methods: `keys()`, `values()`, or `items()`. Combining two
dictionaries is easy with the unpacking operator (`{**dict1, **dict2}`) or with the merge operator (`dict1 | dict2`).

### Tuple

> *Use a tuple instead of a list when you need an immutable ordered collection.*

In a tuple, each element can be accessed by its index in a performant way. Like a list, a tuple can contain various
type of elements and the same element multiple times.

### Set

> *Use a set when you don't need an ordered collection, and duplicate elements are not allowed.*

Accessing a set by a value is cheap because Python sets are implemented as hash tables. On the contrary, if you have a list, the whole list may need to be gone through
to find a specific value. If you have a list and want to remove
duplicates from it, you can convert the list into a set: `set(my_list)`. Python also offers frozen sets with the `frozenset` constructor. These sets are immutable.

### String

> *Use a string to store an immutable ordered collection of characters.*

In Python, strings are lists of Unicode characters. Strings are always immutable. Accessing a character by its index is
always a cheap operation O(1).

### Bytearray

> *Use a byte array to store an ordered collection of values between 0 and 256.*

A byte array is created with the `bytearray` constructor. Accessing a byte by its index is always a cheap operation O(1).
Here are two examples of creating a byte array: `bytearray((255, 50, 20)` or `bytearray(b'\xFF\x32\x14')`.

### Counter

> *Use a counter to store counts for various elements.*

A counter is a dictionary where elements are stored as keys, and their counts are stored as values. Counter objects
differ from traditional dictionary objects when a value for a missing key is requested, value zero is returned instead
of a `KeyError`.

### OrderedDict

> *Use the `OrderedDict` class if the dictionary needs to remember the insertion order of entries.*

When you iterate over an `OrderedDict` object, you get the entries in the insertion order.

### Deque (Double Ended Queue)

> *Use a deque when you need cheap insertion and removal of elements at either or both ends of the collection.*

Adding and removing elements at the ends of a deque are cheap (O(1))
operations because the deque is implemented as a doubly linked list. The drawback of the deque is that randomly
accessing an element at a specific index is slow (O(n)).

### Customized Built-In Collections

> *If you need to customize the behavior of a built-in list, string, or dictionary, make your custom class extend one of the following classes: `UserList`, `UserString`, or `UserDict`.*

### Stack (LIFO Queue)

> *A stack can be implemented using a deque.*

You can push an element into the stack with the deque's `append` method and pop an element out of the stack with the deque's `pop` method.
You can also implement a stack using a list, but operations can be slower sometimes, especially if the stack is large.
When you implement a stack using a list, you use the `append` and `pop` methods like with a deque.

### Queue (FIFO Queue)

> *A queue can be implemented using a deque.*

You can add an element to a queue with the deque's `append` method and pop an element from the queue with the deque's `popleft` method.
You can also implement a queue using a list, but operations can be slower sometimes, especially if the queue is large.
When you implement a queue using a list, you use the `append` and `pop(0)` methods.

### Priority Queue

> *Use a priority queue to retrieve elements based on their priority.*

You can implement a priority queue using the `PriorityQueue` class from the `queue` module. That class is also thread-safe.

### Synchronized Queues (LIFO/FIFO)

> *Use a synchronized queue for implementing thread-safe multi-consumer, multi-producer queues.*

Python provides two thread-safe queue implementations in the `queue` module: `Queue` and `LifoQueue`.

## Optimization Principle

Code optimization makes code run faster and/or consume less memory.
Faster code improves the end-user experience, and optimization reduces the need for computing resources (CPU/memory), making operating the software cheaper.

> ***Avoid premature optimization. Premature optimization may hinder crafting a proper object-oriented design for a software component.***

Measure unoptimized performance first. Then, decide if optimization is needed. Implement optimizations individually and
measure the performance after each optimization to determine if the particular optimization matters. You can then utilize
the knowledge you gained in future projects only to make optimizations that boost performance significantly enough.
Sometimes, you can make performance optimization in the early phase of a project if you know that a particular optimization
is needed (e.g., from previous experience), and the optimization can be implemented without negatively affecting the
object-oriented design.

### Optimization Patterns

The following optimization patterns are described in this section:

- Optimize busy loops only pattern
- Remove unnecessary functionality pattern
- Object pool pattern
- Use optimal data structures pattern
- Algorithm complexity reduction pattern
- Cache function results pattern
- Buffer file I/O pattern
- Share identical objects, a.k.a flyweight pattern

#### Optimize Busy Loops Only Pattern

Optimizations should primarily target only the busy loop or loops in a software component. Busy loops are the loops in threads that
execute over and over again, possibly thousands or more iterations in a second. Performance optimization should not target
functionality that executes only once or a couple of times during the software component's lifetime, and running that
functionality does not take a long time. For example, an application can execute configuration reading and parsing
functionality when it starts. This functionality takes a short time to execute. It is
not reasonable to optimize that functionality because it runs only once.
It does not matter if you can read and parse the configuration in 200 or 300 milliseconds, even if there is a 50% difference in performance.

Let's use the data exporter microservice as an example. Our data exporter microservice consists of input, transformer, and output parts.
The input part reads messages from a data source. We cannot affect the message reading part if we use a 3rd party library for that purpose.
Of course, if multiple 3rd party libraries are available, it is possible to craft performance tests and evaluate which library offers the best performance.
If several 3rd party libraries are available for the same functionality, we tend to use the
most popular library or a library we know beforehand. If performance is an issue, we should evaluate different libraries and compare their performances.

The data exporter microservice has the following functionality in its busy loop: decode an input message to an internal message, perform
transformations, and encode an output message. Decoding an input message requires
decoding each field in the message. Let's say there are 10000 messages handled per second, each with 100 fields.
During one second, 100,000 fields must be decoded. This reveals that the optimization of the decoding functionality
is crucial. The same applies to output message encoding. We at Nokia have implemented the decoding and encoding Avro binary fields ourselves.
We were able to make them faster than what was provided by a 3rd party library.

#### Remove Unnecessary Functionality Pattern

Removing unnecessary functionality is something that will boost performance. Every now and then, you should stop and think critically about your software component:
Is my software component doing only the necessary things considering all circumstances?

Let's consider the data exporter's functionality in a special case. It is currently decoding an input message to an internal message.
This internal message is used when making various transformations to the data. Transformed data is encoded to a wanted output format.
The contents of the final output message can be a small subset
of the original input message. This means that only a tiny part of the decoded message is used. In that case, it is unnecessary
to decode all the fields of an input message if, for example, only 10% of the fields are used in the transformations and
output messages. By removing unnecessary decoding, we can improve
the performance of the data exporter microservice.

#### Object Pool Pattern

In garbage-collected languages like Python, the benefit of using an object pool is evident from the
garbage-collection point of view. Objects are created only once in the object pool pattern and then reused.
This will take pressure away from garbage collection. If we didn't use an object pool,
new objects could be created in a busy loop repeatedly, and soon after they were created, they
could be discarded. This would cause many objects to be made available for garbage collection in
a short time. Garbage collection takes processor time, and if the garbage collector has a lot of garbage to collect,
it can slow the application down for an unknown duration at unknown intervals.

#### Use Optimal Data Structures Pattern

If you are performing number crunching in your application, do not use the regular Python data structures, but
find a suitable library, like [numpy](https://numpy.org/), that contains optimized data structures for a particular use case.

#### Algorithm Complexity Reduction Pattern

Choose an algorithm with reduced complexity as measured using the [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation). This usually boosts the performance. In the below example, we are using the find algorithm with a list:

```python
values = [1, 2, 3, 4, 5, ..., 2000]
if 2000 in values:
    print("Value 2000 found")
```

The above algorithm must traverse the list, which makes it slower compared to the find algorithm with a set:

```python
values = {1, 2, 3, 4, 5, ..., 2000}
if 2000 in values:
    print("Value 2000 found")
```

The below algorithm (list comprehension) will generate a list of 20,000 values:

```python
values = [value for value in range(20_000)]
```

If we don't need all the 20,000 values in the memory at the same time,
we could use a different algorithm (generator expression) which consumes much less memory,
because not all the 20,000 values are in the memory:

```python
values = (value for value in range(20_000))
```

The type of the `values` object in the above example is `Generator`, which inherits from `Iterator`. You can use
the `values` anywhere an iterator is expected.

#### Cache Function Results Pattern

You can benefit from caching the function results if you have an expensive pure function that always returns the same result for the same input without any side effects. You can cache function results using the `@cache` or `@lru_cache` decorator. Here is an example:

```python
from functools import lru_cache

# Results of 500 most recent calls to the function
# will be cached
@lru_cache(maxsize=500)
def make_expensive_calc(value: int):
    # ...

print(make_expensive_calc(1))
# After the first call,
# the function result for the input value 1
# will be cached

print(make_expensive_calc(1))
# The result of function call is fetched from the cache
```

`@cache` is the same as `@lru_cache(maxsize=None)`, i.e., the cache does not have a maximum size limit.

#### Buffer File I/O Pattern

You can benefit from setting custom buffer sizes if you are reading/writing large files. The below examples set buffer sizes to 1MB:

```python
with open('data.json', 'r', buffering=1_048_576) as data_file:
    data = data_file.read()

with open('data.json', 'w', buffering=1_048_576) as data_file:
    data_file.write(data)
```

#### Share Identical Objects a.k.a Flyweight Pattern

If your application has many objects with some identical properties, those parts of the
objects with identical properties are wasting memory. You should extract the
common properties to a new class and make the original objects reference a shared object of that
new class. Now, your objects share a single common object, and possibly significantly less
memory is consumed. This design pattern is called the *flyweight pattern* and was described in more detail
in the earlier chapter.
