# Coding Principles

This chapter presents principles for coding. The following principles are presented:

- Uniform variable naming principle
- Uniform source code repository structure principle
- Domain-based source code structure principle
- Avoid comments principle
- Function single return statement principle
- Prefer statically typed language principle
- Refactoring principle
- Static code analysis principle
- Error/Exception handling principle
- Avoid off-by-one errors principle
- Be critical when googling principle
- Make one change at a time principle
- Choosing right 3rd party component principle
- Use appropriate data structure principle
- Optimization principle

## Uniform Variable Naming Principle

> ***A good variable name should describe the variable's purpose and its type.***

Writing your code with great names, at best, makes it read like prose. And remember that code is more
often read than written, so code must be easy to read and understand.

Naming variables with names that convey information about the variable's type is crucial in untyped languages
and beneficial in typed languages because modern typed languages use automatic type deduction, and you won't always see the
actual variable type. But when the variable's name tells its type, it does not matter if the type name is not visible.

If a variable name is 20 or more characters long, consider making it shorter. Try to abbreviate
one or more words in the variable name, but only use meaningful and well-known abbreviations. If such abbreviations don't exist, then
don't abbreviate at all. For example, if you have a variable named `environmentVariableName`, you should try to shorten it because
it is over 20 characters long. You can abbreviate *environment* to *environ* and *variable* to *var*, resulting in a variable
name `environVarName` that is short enough. Both abbreviations `environ` and `var` are commonly used and well understood.
Let's have another example with a variable named `loyaltyBonusPercentage`. You cannot abbreviate *loyalty*. You cannot abbreviate
*bonus*. But you can abbreviate *percentage* to *percent* or even *pct*. I would rather use *percent* instead of *pct*. Using
*percent* makes the variable name shorter than 20 characters. The maximum length of a variable name should be less than the maximum
length for a class/interface name because variables are used in code more often and often in combination with a method name.

If a variable name is less than 20 characters long, you don't need to shorten it. If you have several variables named in
similar wording and one or more need abbreviating, you can use that abbreviation for consistency in all the variable names. For example, if you have variables `configurationFile` and `configurationFilePparser`, you
can abbreviate both to `configFile` and `configFileParser`.

In the following sections, naming conventions for different types of variables are proposed.

### Naming Integer Variables

Some variables are intrinsically integers, like *age* or *year*. Everybody immediately understands that the type of
an *age* or *year* variable is a number and, more specifically, an integer. So, you don't have to add anything to the variable's
name to indicate its type. It already tells you its type.

One of the most used categories of integer variables is a count or number of something. You see those kinds of variables in every piece
of code. I recommend using the following convention for naming those variables: *numberOf&lt;something&gt;* or alternatively
*&lt;something&gt;Count*. For example, *numberOfFailures* or *failureCount*. You should not use a variable named *failures*
to designate a failure count. The problem with that variable name is that it does not specify the variable type, which can confuse. This is because a variable named *failures* can be misunderstood as a collection variable
(e.g., a list of failures).

If the unit of a variable is not self-evident, always add information about the unit to the end of the variable name. For example, instead of
naming a variable *tooltipShowDelay*, you should name it *tooltipShowDelayInMillis* or *tooltipShowDelayInMs*. If you have a variable
whose unit is self-evident, unit information is not needed. So, there is no need to name an *age* variable as *ageInYears*. But if you are
measuring age in months, you must name the respective variable as *ageInMonths* so that people don't assume that age is measured in
years.

### Naming Floating-Point Number Variables

Floating-point numbers are not as common as integers, but sometimes you need them too. Some values are intrinsically floating-point numbers,
like most un-rounded measures (e.g., price, height, width, or weight). A floating-point variable would be a safe bet if you need to store a measured value.

If you need to store an amount of something that is not an integer, use a variable named *&lt;something&gt;Amount*, like *rainfallAmount*.
When you see the “amount of something” in code, you can automatically think it is a floating-point number. If you need to use a number in arithmetic,
depending on the application, you might want to use either floating-point or integer arithmetic. In the case of money, you should use
integer arithmetic to avoid rounding errors. Instead of a floating-point *moneyAmount* variable, you should have
an integer variable, like *moneyInCents*.

If the unit of a variable is not self-evident, add information about the unit to the end of the variable name, like *rainfallAmountInMm*, *widthInInches*,
*angleInDegrees* (values 0-360), *failurePercent* (values 0-100), or *failureRatio* (values 0-1).

### Naming Boolean Variables

Boolean variables can have only one of two values: true or false. The name of a boolean variable should form a statement where the answer is
true or false, or yes or no. Typical boolean variable naming patterns are: *is&lt;something&gt;*, *has&lt;something&gt;*, *did&lt;something&gt;*,
*should&lt;something&gt;*, *can&lt;something&gt;, or *will&lt;something&gt;*. Some examples of variable names following the above patterns are
*isDisabled*, *hasErrors*, *didUpdate*, *shouldUpdate*, and *willUpdate*.

The verb in the boolean variable name does not have to be at the beginning. It can and should be in the middle if it improves the code's readability.
Boolean variables are often used in if-statements where changing the word order in the variable name can make the code read
better. Remember that, at best, code reads like beautiful prose and is read more often than written.

Below is a C++ code snippet where we have a boolean variable named `isPoolFull`:

```cpp
if (const bool isPoolFull = m_pooledMessages.size() >= 200U;
      isPoolFull)
{
  // ...
}
else
{
  // ...
}
```

We can change the variable name to `poolIsFfull` to make the if-statement read more fluently. In the below example, the if-statement
reads "if poolIsFull" instead of "if isPoolFull":

```cpp
if (const bool poolIsFull = m_pooledMessages.size() >= 200U;
      poolIsFull)
{
  // ...
```

Don't use boolean variable names in the form of *&lt;passive-verb&gt;Something*, like *insertedField*, because this can confuse the reader.
It is unclear if the variable name is a noun (a field that was inserted) that names an object or a boolean statement.
Instead, use either *didInsertField* or *fieldWasInserted*.

Below is a Go language example of the incorrect naming of a variable used to store a function return value. Someone might think
`tablesDropped` means a list of dropped table names. So, the name of the variable is obscure and should be changed.

```go
tablesDropped := dropRedundantTables(prefix,
                                     vmsdata,
                                     cfg.HiveDatabase,
                                     hiveClient,
                                     logger)
if tablesDropped {
  // ...
}
```

Below is the above example modified so that the variable name is changed to indicate a boolean statement:

```go
tablesWereDropped := dropRedundantTables(prefix,
                                         vmsdata,
                                         cfg.HiveDatabase,
                                         hiveClient,
                                         logger)
if tablesWereDropped {
  // ...
}
```

You could have used a variable named `didDropTables`, but the `tablesWereDropped` makes the if-statement more readable.
If the return value of the `dropRedundantTables` function were a list of dropped table names, I would name the
return value receiving variable as `droppedTableNames`.

When you read code containing a negated boolean variable, it usually reads terrible, for example:

```java
final var appWasStarted = app.start();

// Reads: if not app was started
if (!appWasStarted) {
  // ...
}
```

To improve the readability, you can mentally move the `not` word to the correct place to make the sentence
read like proper English. For example: *if appWas not Started*

The other option is to negate the variable. That is done by negating both sides of the assignment by adding
`not` on both sides of the assignment operator. Here is an example:

```java
final var appWasNotStarted = !app.start();

if (appWasNotStarted) {
  // ...
}
```

Below is a real-life example where a boolean property is named wrong:

```
sonar.buildBreaker.skip = true
```

The `skip` is not a correctly named boolean property. From the above statement, it is difficult to understand when a build is broken because no boolean statement that evaluates either true or false is made.
Let's refactor the statement:

```
sonar.shouldBreakBuildOnQualityGateFailure = true
```

### Naming String Variables

String variables are prevalent, and many things are intrinsically strings, like _name_, _title_, _city_, _country_, or _topic_.
When you need to store numerical data in a string variable, tell the code reader clearly that it is a question about a number in
string format, and use a variable name in the following format: _&lt;someValue&gt;String_ or _&lt;someValue&gt;AsString_. It makes
the code more prominent and easier to understand. Here is an example in JavaScript:

```js
const year = parseInt(yearAsString, 10);
```

If you have a string variable that could be confused with an object variable, like `schema` (could be confused with an instance of `Schema` class), but it is a string,
add *string* to the end of the variable name, e.g., `schemaString`. Here is an example:

```java
final var schema = schemaParser.parse(schemaString);
```

### Naming Enum Variables

Name enum variables using the same name as the enum type. E.g., a `CarType` enum variable should be named `carType`.
If the name of an enum type is very generic, like `Result`, you might benefit from declaring an enum variable with some
detail added to the variable name. Below is an example of a very generic enum type name:

{title: "PulsarProducer.cpp"}
```cpp
// Returns enum type 'Result'
const auto result = pulsar::createProducer(...);

if (result == Result.Ok) {
  // ...
}
```

Let's add some detail and context to the `result` variable name:

{title: "PulsarProducer.cpp"}
```cpp
const auto producerCreationResult = pulsar::createProducer(...);

if (producerCreationResult == Result.Ok) {
  // ...
}

### Naming Collection (List and Set) Variables

When naming lists and sets, you should use the plural form of a noun, like *customers*, *errors*, or *tasks*. These kinds of names work well in the code, for example:

```ts
function handle(customers: Customer[]): Customer[] {
  // ...
}

const customers = [new Customer()];

for (const customer of customers) {
  // ...
}

const processedCustomers = handle(customers);

function isEven(integer: number): boolean {
  return integer % 2 === 0;
}

const integers = [1, 2, 3, 4, 5];
const evenIntegers = integers.filter(isEven);
```

This plural noun naming convention is usually enough because you don't necessarily need to know the underlying collection implementation. Using this naming convention
allows you to change the type of a collection variable without changing the variable name.
If you are iterating over a collection, it does not matter if it is a list or set. Thus, it does not bring any
benefit if you add the collection type name to the variable name, for example, *customerList* or *taskSet*. Those names are just longer.
You might want to specify the collection type in some special cases. Then, you can use the following kinds of variable names:
*queueOfTasks*, *stackOfCards*, or *setOfTimestamps*.

Below is an example in Go language, where the function is named correctly to return a collection (of categories), but the variable
receiving the return value is not named according to the collection variable naming convention:

```go
vmsdata, error = vmsClient.GetCategories(vmsUrl, logger)
```

Correct naming would be:

```go
vmsCategories, error = vmsClient.GetCategories(vmsUrl, logger)
```

### Naming Map Variables

Maps are accessed by requesting a _value_ for a certain _key_. I recommend naming maps using the pattern _keyToValue_ or keyToValueMap_.
Let’s say we have a map containing order counts for customer ids. This map should be named `customerIdToOrderCount` or `customerIdToOrderCountMap`.
Or if we have a list of suppliers for product names, the map variable should be named `productNameToSuppliers` or `productNameToSuppliersMap`.
I prefer the shorter version because it is enough to tell that a variable is a map because of the `to` word in the middle.
Below is an example of accessing maps in Java:

```java
final var orderCount = customerIdToOrderCount.get(customerId);
final var suppliers = productNameToSuppliers.get(productName);
```

Below is an example of iterating over a map in JavaScript:

```ja
Object.entries(customerIdToOrderCount)
      .map(([customerId, orderCount]) => ...);
```

### Naming Pair and Tuple Variables

A variable containing a pair should be named using the pattern _variable1AndVariable2_. For example: `heightAndWidth`. And for tuples,
the recommended naming pattern is _variable1Variable2...andVariableN_. For instance: `heightWidthAndDepth`.

Below is an example of using pairs and tuples in JavaScript:

```js
const heightAndWidth = [100, 200];
const heightWidthAndDepth = [100, 200, 40];
const [height, , depth] = heightWidthAndDepth;
```

### Naming Object Variables

Object variables refer to an instance of a class. Class names are nouns written in CapWords, like
*Person*, *CheckingAccount*, or *Task*. Object variable names should contain the related class name: a *person* object of
the *Person* class, an *account* object of the *Account* class, etc. You can freely decorate the object’s name, for example, with
an adjective: *completedTask*. Including the class name or at least a significant part of it at the end of the variable name is useful because looking at the end of the variable name tells what kind of object is in question.

Do not add an article `a` or `an` to an object variable's name. This is redundant because you usually know if it is a question about an object variable when you follow all the naming conventions presented in this book.

```java
// Not so good, explicit articles and prepositions and wrong order of arguments
writeTo(aBuffer, aMessage)

// Better, implicit articles and prepositions and correct order of arguments
write(message, buffer)
```

Sometimes, you might want to name an object variable so that the name of its class is implicit, for example:

```java
// The class of the function parameters, 'Location', is implicit
drive(home, destination);
```

In the above example, the classes of `home` and `destination` objects are not explicit. In most cases, it is preferable to make the class name
explicit in the variable name when it does not make the variable name too long. This is because of the variable type deduction.
The types of variables are not necessarily visible in the code, so the
variable name should communicate the type of a variable. Below is an example where the types of function parameters are explicit.

```java
// The class of the function parameters, 'Location', is now explicit
drive(homeLocation, destLocation);
```

### Naming Optional Variables

How to name optional variables depends on the programming language and how the optional types are implemented. An optional variable name should be prefixed with _maybe_ in languages where you must unwrap the possible value from an optional object.

In Java, when using Optional&lt;T&gt;, name variables of this type using the following pattern: _maybe&lt;Something&gt;_:

```java
maybeLoggedInUser.ifPresent(loggedInUser -> loggedInUser.logout());
final User currentUser = maybeLoggedInUser.orElse(guestUser);
```

In TypeScript and other languages where optional types are created using type unions, you don’t need prefixes
in optional variable names. In the below example, the `discount` parameter is optional, and its type is `number | undefined`:

```ts
function addTax(
  price: number,
  discount?: number
): number {
  return 1.2 * (price — (discount ?? 0));
}

const priceWithTax = addTax(priceWithoutTax);
```

### Naming Function Variables (Callbacks)

Callback functions are functions supplied to other functions to be called at some point. If a callback function returns a value,
it can be named according to the returned value, but it should still contain a verb.
If the callback function does not return a value, you should name the callback function like any other function, indicating what the function does. Suppose you have a variable storing a function object, like a Java `Function` instance. In that case, you need to name the variable according to the rules for an object variable, i.e., the variable name should be a noun. For example, if you have a Java `Function` object currently named `map`, you should correct the name as a noun, like `mapper`.

```js
const doubled = value => 2 * value;
const squared = value => value * value;
const isEven = nbr => (nbr % 2) === 0;
const values = [1, 2, 3, 4, 5]

// You can imagine an implicit "to" preposition after the map function name
const doubledValues = values.map(doubled);
const squaredValues = values.map(squared);

const evenValues = values.filter(isEven);

const strings = [" string1", "string2 "];
const trimmed = str => str.trim();
const trimmedStrings = strings.map(trimmed);

const sumOfValues = (sum, value) => sum + value;
// You can imagine an implicit "to" preposition after the reduce function name
values.reduce(sumOfValues, 0);
```

Let's have a quick detour with an example written in Clojure:

```clojure
(defn print-first-n-doubled-integers [n]
  (println (take n (map (fn [x] (* 2 x)) (range)))))
```

To understand what happens in the above code, you should start reading from the innermost function call and
proceed toward the outermost function call. A function call is inside parenthesis. When traversing the function call hierarchy, the difficulty lies in storing
and retaining information about all the nested function calls in short-term memory.

We could simplify reading the above example by naming the anonymous function and introducing variables (constants) for intermediate
function call results. Of course, our code becomes more prolonged, but coding is not a competition to write the shortest possible code
but to write the shortest, most readable, and understandable code for other people and your future self. It is a compiler's job
to compile the longer code below into code that is as efficient as the shorter code above.

Below is the above code refactored:

```clojure
(defn print-first-n-doubled-integers [n]
  (let [doubled (fn [x] (* 2 x))
        doubled-integers (map doubled (range))
        first-n-doubled-integers (take n doubled-integers)]
          (println first-n-doubled-integers)))
```

Let's think hypothetically: if Clojure's `map` function took parameters in a different order and the `range` function was
named `integers` and the `take` function was named `take-first` (like there is the `take-last` function), we would have an even more explicit version
of the original code:

```clojure
(defn print-first-n-doubled-integers [n]
  (let [doubled (fn [x] (* 2 x))
        doubled-integers (map (integers) doubled)
        first-n-doubled-integers (take-first n doubled-integers)]
          (println first-n-doubled-integers)))
```

There is a reason why the `map` function takes the parameters in that order. It is to make function partial application
possible.

### Naming Class Properties

Class properties (i.e., class attributes, fields, or member variables) should be named so that the class name is not repeated in the
property names. Below is a Java example of incorrect naming:

```java
public class Order {
  private long orderId;
  private OrderState orderState;
}
```

Below is the above code with corrected names:

```java
public class Order {
  private long id;
  private OrderState state;
}
```

If you have a class property to store a callback function (e.g., event handler or lifecycle callback), you should name it so that it tells on what occasion the stored
callback function is called. You should name properties storing event handlers using the
following pattern: `on` + `<event-type>`, e.g., `onClick` or `onSubmit`. Name properties storing lifecycle callbacks in a similar way you
would name a lifecycle method, for example: `onInit`, `afterMount`, or `beforeMount`.

### General Naming Rules

#### Use Short, Common Names

When picking a name for something, use the most common shortest name. If you have a function named _relinquishSomething_, consider a shorter and more common name for the function. You could rename the function to _releaseSomething_, for example. The word "release" is
shorter and more common than the "relinquish" word. Use
Google to search for word synonyms, e.g., "relinquish synonym", to find the shortest and most common similar term.

#### Pick One Term And Use It Consistently

Let's assume that you are building a data exporter microservice and you are currently using the following terms in the code:
_message_, _report_, _record_ and _data_. Instead of using four different terms to describe the same thing, you should pick just one term,
like _message_, for example, and use it consistently throughout the microservice code.

Suppose you need to figure out a term to indicate a property of a class. You should pick just
one term, like _property_, and use it consistently everywhere. You should not use multiple terms like
_attribute_, _field_, and _member_ to describe a class property.

If you have `person` objects, do not add them to a `peopleList`; add them to a `persons` list. Do not use the terms person and people interchangeably.

#### Avoid Obscure Abbreviations

Many abbreviations are commonly used, like *str* for a string, *num/nbr* for a number, *prop* for a property, or *val* for a value.
Most programmers use these, and I use them to make long names shorter. If a variable name is short, the full name should be used,
like *numberOfItems* instead of *nbrOfItems*. Use abbreviations when the variable name becomes too long (20 or more characters).
You should especially avoid using uncommon abbreviations. For example, do not abbreviate *amount* to *amnt* or *discount* to *dscnt* because those abbreviations are not used.

#### Avoid Too Short Or Meaningless Names

Names that are too short do not communicate what the variable is about. Variable names like *tmp*, *temp*, *ret*, or *retval* are all meaningless. You should
figure out a name that describes the value a variable holds. This is not always an easy task, and naming things is
hard and one of the hardest things in software engineering. The good news is that you get better at it with more practice. As loop counters, use a variable name like _index_ or _&lt;something&gt;Index_ if the loop variable is used to index something, like
an array, for example. An indexing variable should start from zero. If the loop variable is counting the number of things, use _number_ or
_&lt;something&gt;Number_ as the variable name, and start the loop counter from value one instead of zero. For example,
a loop to start five threads should be written in C++ in the following way:

```cpp
for (size_t threadNumber{1U}; threadNumber <= 5U; ++threadNumber)
{
  startThread(threadNumber);
}
```

If you don't need to use the loop counter value inside the loop, you can use a loop variable named _count_:

```cpp
for (size_t count{1U}; count <= objectCount; ++count)
{
  objects.push_back(acquireObject(std::forward<Args>(args)...));
}
```

Let's have another example. Suppose you have a class named `ImageGetter` with a method `getImage`. Both of the names are
too abstract and can mean several things in practice, like the image could be gotten from a local disk, local cache, database, or remote location.
If the `ImageGetter` is always getting images from a remote location, it is better to name the class with a descriptive name, like `ImageDownloader`,
and have a method `downloadImage` in it.
You should not use abstract names with concrete classes, but you can create an interface named `ImageGetter` with a method `getImage`.
This is because, by nature, interfaces are abstract, and you cannot create an instance of them. You can then create concrete implementations
of the `ImageGetter` interface, like `LocalDiskImageGetter`, `LocalCacheImageGetter`, `MySqlDbImageGetter`, or `RemoteUrlImageGetter`.

Even if you don't agree with all naming conventions presented here and in the previous chapter, I recommend you create rules for naming code entities, like classes, functions, and variables. That would make your code look
consistent and professional. It makes the code look pretty bad if no naming conventions are used, and naming inside a single module or even a function varies dramatically. For example, a 'customers' variable is used somewhere, while a `customer_list` variable is used elsewhere, and the `customers` variable is used to store a list of customers in some place and the number of customers in another place. It is preferable if a whole development team or, even better, all development teams could share a common set of naming conventions.

## Uniform Source Code Repository Structure Principle

> ***Structuring a source code repository systematically in a certain way makes it easy for other developers to discover wanted information quickly.***

Below are examples of ways to structure source code repositories for Java, C++, and JavaScript/TypeScript microservices.
In the below examples, a containerized (Docker) microservice deployed to a Kubernetes cluster is assumed. Your CI tool might require that the CI/CD pipeline code reside in a specific directory. If not, place it in a _ci-cd_ directory.

Top-level source code repository directory names can contain dashes, but package/directory names inside the *src* directory
should not contain separator characters. This is not mandatory in all languages, but it is in Java.

### Java Source Code Repository Structure

Below is the proposed source code repository structure for a Java microservice (Gradle build tool is used):

```
java-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── gradle
│   └── wrapper
│       └── ...
├── helm
│   └── java-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com.domain.java-service
│   │   │       └── // source code
│   │   └── resources
│   └── test
│       ├── java
│       │   └── com.domain.java-service
│       │       └── // unit test code
│       └── resources
├── .gitignore
├── build.gradle
├── gradlew
├── gradlew.bat
├── README.MD
└── settings.gradle
```

### C++ Source Code Repository Structure

Below is the proposed source code repository structure for a C++ microservice (CMake build tool is used):

```
cpp-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── helm
│   └── cpp-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   ├── // source code here
│   │   main.cpp
│   └── CMakeLists.txt
├── test
│   ├── // unit test code
│   │   main.cpp
│   └── CMakeLists.txt
├── .gitignore
├── CMakeLists.txt
└── README.MD
```

### JavaScript/TypeScript Source Code Repository Structure

Below is the proposed source code repository structure for a JavaScript/TypeScript microservice:

```
ts-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── helm
│   └── ts-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   └── // source code here
├── test
│   └── // unit test code here
├── .gitignore
├── .eslintrc.json
├── .prettier.rc
├── package.json
├── package-lock.json
├── README.MD
└── tsconfig.json
```

Unit test modules should be in the same directory as source code modules, but you can also put them in a specific *test* directory.

## Domain-Based Source Code Structure Principle

> ***Structure the source code tree primarily by domains (or feature sets), not by technical details. Each source code directory should have a single responsibility at its abstraction level.***

Below is an example of a Spring Boot microservice's _src_ directory that is not organized by domains (or feature sets) but is
incorrectly organized according to technical details:

```
spring-example-service/
└── src/
    └── main/java/
        └── com.silensoft.springexampleservice/
            ├── controllers/
            │   ├── AController.java
            │   └── BController.java
            ├── entities/
            │   ├── AEntity.java
            │   └── BEntity.java
            ├── errors/
            │   ├── AError.java
            │   └── BError.java
            ├── dtos/
            │   ├── ADto.java
            │   └── BDto.java
            ├── repositories/
            │   ├── DbAEntity.java
            │   ├── DbBEntity.java
            │   ├── ARepository.java
            │   └── BRepository.java
            └── services/
                ├── AService.java
                └── BService.java
```

Below is the above example modified so that directories are organized by domains (or feature sets):

```
spring-example-service/
└── src/
    └── main/java/
        └── com.silensoft.springexampleservice/
            ├── domainA/
            │   ├── AController.java
            │   ├── ADbEntity.java            │
            │   ├── ADto.java
            │   ├── AEntity.java
            │   ├── AError.java
            │   ├── ARepository.java
            │   └── AService.java
            └── domainB/
                ├── BController.java
                ├── BDbEntity.java
                ├── BDto.java
                ├── BEntity.java
                ├── BError.java
                ├── BRepository.java
                └── BService.java
```

You can have several levels of nested domains:

```
spring-example-service/
└── src/
    └── main/java/
        └── com.silensoft.springexampleservice/
            ├── domainA/
            │   ├── domainA-1/
            │   │   ├── A1Controller.java
            │   │   └── ...
            │   └── domainA-2/
            │       ├── A2Controller.java
            │       └── ...
            └── domainB/
                └── BController.java

```

If you want, you can create subdirectories for technical details inside a domain directory. This is the recommended
approach if, otherwise, the domain directory would contain more than 5 to 7 files. Below is an example of the _salesitem_ domain:

```
sales-item-service
└── src
    └── main/java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── dtos
                │   ├── InputSalesItem.java
                │   └── OutputSalesItem.java
                ├── entities
                │   └── SalesItem.java
                ├── errors
                │   ├── SalesItemRelatedError.java
                │   └── SalesItemRelatedError2.java
                ├── repository
                │   ├── DbSalesItem.java
                │   └── SalesItemRepository.java
                ├── service
                │   ├── SalesItemService.java
                │   └── SalesItemServiceImpl.java
                └── SalesItemController.java
```

To highlight the *clean microservice design principle*, we could also use the following kind of directory
layout:

```
sales-item-service
└── src
    └── main/java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── businesslogic
                │    ├── dtos
                │    │   ├── InputSalesItem.java
                │    │   └── OutputSalesItem.java
                │    ├── entities
                │    │   └── SalesItem.java
                │    ├── errors
                │    │   ├── SalesItemServiceError.java
                │    │   └── SalesItemServiceError2.java
                │    ├── repository
                │    │   └── SalesItemRepository.java
                │    └── service
                │        ├── SalesItemService.java
                │        └── SalesItemServiceImpl.java
                ├── RestSalesItemController.java
                └── SqlSalesItemRepository.java
```

The *businesslogic* directory could also be named *core* or *model**.

Or if we have multiple input interface adapters (controllers) and output interface adapters (repositories):

```
sales-item-service
└── src
    └── main/java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── businesslogic
                │    ├── dtos
                │    │   ├── InputSalesItem.java
                │    │   └── OutputSalesItem.java
                │    ├── entities
                │    │   └── SalesItem.java
                │    ├── errors
                │    │   ├── SalesItemServiceError.java
                │    │   └── SalesItemServiceError2.java
                │    ├── repository
                │    │   └── SalesItemRepository.java
                │    └── service
                │        ├── SalesItemService.java
                │        └── SalesItemServiceImpl.java
                ├── controllers
                │    ├── RestSalesItemController.java
                │    └── GraphQlSalesItemController.java
                └── repositories
                     ├── SqlSalesItemRepository.java
                     └── MongoDbSalesItemRepository.java
```

You can even put the *controllers* and *repositories* directories under a *ifadapters* directory.
You can even do it like this: *ifadapters/input/controllers* and *ifadapters/output/repositories*. If your microservices
uses external services, you can put those in the *ifadapters/output/services* directory. You can also name your application
services as use cases, e.g., `businesslogic/usescases/SalesItemUseCases[Impl].java`.

If you follow the *clean microservice design* principle and add or change an interface adapter (e.g., a controller or a repository),
you should not need to make any code changes to the business logic part of the service (the *businesslogic* directory).

Below is the source code directory structure for the data exporter microservice designed in the previous
chapter. There are subdirectories for the four subdomains: input, internal message, transformer, and output. A subdirectory is created for each common
nominator in the class names. It is effortless to navigate the directory
tree when locating a particular file. Also, the number of source code files in each directory is low.
You can grasp the contents of a directory with a glance. The problem with directories containing many files
is that it is not easy to find the wanted file. For this reason, a single directory should ideally have 2-4 files. The absolute
maximum is 5-7 files.

Note that a couple of directories are left unexpanded below to shorten the example. It should be easy for the reader
to infer the contents of the unexpanded directories.

```
src
├── common
├── input
│   ├── config
│   │   ├── parser
│   │   │   ├── json
│   │   │   │   ├── JsonInputConfigParser.cpp
│   │   │   │   └── JsonInputConfigParser.h
│   │   │   └── InputConfigParser.h
│   │   ├── reader
│   │   │   ├── localfilesystem
│   │   │   │   ├── LocalFileSystemInputConfigReader.cpp
│   │   │   │   └── LocalFileSystemInputConfigReader.h
│   │   │   └── InputConfigReader.h
│   │   ├── InputConfig.h
│   │   ├── InputConfigImpl.cpp
│   │   └── InputConfigImpl.h
│   │
│   └── message
│       ├── consumer
│       │   ├── kafka
│       │   │   ├── KafkaInputMessageConsumer.cpp
│       │   │   └── KafkaInputMessageConsumer.h
│       │   └── InputMessageConsumer.h
│       ├── decoder
│       │   ├── avrobinary
│       │   │   ├── AvroBinaryInputMessageDecoder.cpp
│       │   │   └── AvroBinaryInputMessageDecoder.h
│       │   └── InputMessageDecoder.h
│       ├── kafka
│       │   ├── KafkaInputMessage.cpp
│       │   └── KafkaInputMessage.h
│       │
│       └── InputMessage.h
├── internalmessage
    ├── field
│   ├── InternalMessage.h
│   ├── InternalMessageImpl.cpp
│   └── InternalMessageImpl.h
├── transformer
│   ├── config
│   │   ├── parser
│   │   ├── reader
│   │   ├── TransformerConfig.h
│   │   ├── TransformerConfigImpl.cpp
│   │   └── TransformerConfigImpl.h
│   ├── field
│   │   ├── copy
│   │   │   ├── CopyFieldTransformer.cpp
│   │   │   └── CopyFieldTransformer.h
│   │   ├── expression
│   │   ├── filter
│   │   ├── typeconversion
│   │   ├── FieldTransformer.h
│   │   ├── FieldTransformers.h
│   │   ├── FieldTransformaresImpl.cpp
│   │   └── FieldTransformersImpl.h
│   └── message
│       ├── MessageTransformer.h
│       ├── MessageTransformerImpl.cpp
│       └── MessageTransformerImpl.h
└── output
    ├── config
    │   ├── parser
    │   ├── reader
    │   ├── OutputConfig.h
    │   ├── OutputConfigImpl.cpp
    │   └── OutputConfigImpl.h
    └── message
        ├── encoder
        │   ├── avrobinary
        │   └── OutputMessageEncoder.h
        ├── producer
        │   ├── pulsar
        │   └── OutputMessageProducer.h
        ├── OutputMessage.h
        ├── OutputMessageImpl.cpp
        └── OutputMessageImpl.h
```

Below is the Java version of the above directory structure:

```
src
├── common
├── input
│   ├── config
│   │   ├── parser
│   │   │   ├── InputConfigParser.java
│   │   │   └── JsonInputConfigParser.java
│   │   ├── reader
│   │   │   ├── InputConfigReader.java
│   │   │   └── LocalFileSystemInputConfigReader.java
│   │   ├── InputConfig.java
│   │   └── InputConfigImpl.java
│   └── message
│       ├── consumer
│       │   ├── InputMessageConsumer.java
│       │   └── KafkaInputMessageConsumer.java
│       ├── decoder
│       │   ├── InputMessageDecoder.java
│       │   └── AvroBinaryInputMessageDecoder.java
│       ├── InputMessage.java
│       └── KafkaInputMessage.java
├── internalmessage
│   ├── field
│   ├── InternalMessage.java
│   └── InternalMessageImpl.java
├── transformer
│   ├── config
│   ├── field
│   │   ├── impl
│   │   │   ├── CopyFieldTransformer.java
│   │   │   ├── ExpressionFieldTransformer.java
│   │   │   ├── FilterFieldTransformer.java
│   │   │   └── TypeConversionFieldTransformer.java
│   │   ├── FieldTransformer.java
│   │   ├── FieldTransformers.java
│   │   └── FieldTransformersImpl.java
│   └── message
│       ├── MessageTransformer.java
│       └── MessageTransformerImpl.java
└── output
    ├── config
    └── message
```

We could also structure the code according to the *clean microservice design* in the following way:

```
src/main/java
├── common
├── businesslogic
│   ├── input
│   │   ├── config
│   │   │   ├── InputConfig.java
│   │   │   ├── InputConfigImpl.java
│   │   │   ├── InputConfigParser.java
│   │   │   └── InputConfigReader.java
│   │   └── message
│   │       ├── InputMessage.java
│   │       ├── InputMsgConsumer.java
│   │       └── InputMsgDecoder.java
│   ├── internalmessage
│   │   ├── field
│   │   ├── InternalMessage.java
│   │   └── InternalMessageImpl.java
│   ├── transformer
│   │   ├── config
│   │   ├── field
│   │   │   ├── impl
│   │   │   │   ├── CopyFieldTransformer.java
│   │   │   │   ├── ExprFieldTransformer.java
│   │   │   │   ├── FilterFieldTransformer.java
│   │   │   │   └── TypeConvFieldTransformer.java
│   │   │   ├── FieldTransformer.java
│   │   │   ├── FieldTransformers.java
│   │   │   └── FieldTransformersImpl.java
│   │   └── message
│   │       ├── MsgTransformer.java
│   │       └── MsgTransformerImpl.java
│   └── output
│       ├── config
│       └── message
└── ifadapters
    ├── config
    │   ├── parser
    │   │   └── json
    │   │       ├── JsonInputConfigParser.java
    │   │       ├── JsonTransformerConfigParser.java
    │   │       └── JsonOutputConfigParser.java
    │   └── reader
    │       └── localfilesystem
    │           ├── LocalFileSystemInputConfigReader.java
    │           ├── LocalFileSystemTransformerConfigReader.java
    │           └── LocalFileSystemOutputConfigReader.java
    ├── input
    │   ├── kafka
    │   │   ├── KafkaInputMsgConsumer.java
    │   │   └── KafkaInputMessage.java
    │   └── AvroBinaryInputMsgDecoder.java
    └── output
        ├── CsvOutputMsgEncoder.java
        └── PulsarOutputMsgProducer.java
```

From the above directory structure, we can easily see the following:

- Configurations are in JSON format and read from the local file system
- For the input, Avro binary messages are read from Apache Kafka
- For the output, CSV records are produced to Apache Pulsar

Any change we want or need to make in the *ifadapters* directory should not affect the business logic part in the
*businesslogic* directory.

Below is the source code directory structure for the anomaly detection microservice designed in the previous
chapter. The _anomaly_ directory is expanded. Our implementation uses JSON for various parsing activities and self-organizing maps (SOM) is used for anomaly detection. JSON and Kafka are used
to publish anomaly indicators outside the microservice. Adding
new concrete implementations to the below directory structure is straightforward. For example, if we wanted to add YAML support
for configuration files, we could create _yaml_ subdirectories to place YAML-specific implementation classes.

```
src
├── anomaly
│   ├── detection
│   │   ├── configuration
│   │   │   ├── parser
│   │   │   │   ├── json
│   │   │   │   │   ├── JsonAnomalyDetectionConfigParser.cpp
│   │   │   │   │   └── JsonAnomalyDetectionConfigParser.h
│   │   │   │   └── AnomalyDetectionConfigParser.h
│   │   │   ├── AnomalyDetectionConfig.h
│   │   │   ├── AnomalyDetectionConfigFactory.h
│   │   │   ├── AnomalyDetectionConfigFactoryImpl.h
│   │   │   ├── AnomalyDetectionConfigImpl.cpp
│   │   │   └── AnomalyDetectionConfigImpl.h
│   │   ├── engine
│   │   │   ├── AnomalyDetectionEngine.h
│   │   │   ├── AnomalyDetectionEngineImpl.cpp
│   │   │   └── AnomalyDetectionEngineImpl.h
│   │   ├── rule
│   │   │   ├── parser
│   │   │   │   ├── json
│   │   │   │   │   ├── JsonAnomalyDetectionRuleParser.cpp
│   │   │   │   │   └── JsonAnomalyDetectionRuleParser.h
│   │   │   │   └── AnomalyDetectionRuleParser.h
│   │   │   ├── AnomalyDetectionRule.h
│   │   │   ├── AnomalyDetectionRuleFactory.h
│   │   │   ├── AnomalyDetectionRuleFactoryImpl.h
│   │   │   ├── AnomalyDetectionRuleImpl.cpp
│   │   │   └── AnomalyDetectionRuleImpl.h
│   │   ├── AnomalyDetector.h
│   │   ├── AnomalyDetectorImpl.cpp
│   │   └── AnomalyDetectorImpl.h
│   ├── indicator
│   │   ├── publisher
│   │   │   ├── kafka
│   │   │   │   ├── KafkaAnomalyIndicatorPublisher.cpp
│   │   │   │   └── KafkaAnomalyIndicatorPublisher.h
│   │   │   └── AnomalyIndicatorPublisher
│   │   ├── serializer
│   │   │   ├── json
│   │   │   │   ├── JsonAnomalyIndicatorSerializer.cpp
│   │   │   │   └── JsonAnomalyIndicatorSerializer.h
│   │   │   └── AnomalyIndicatorSerializer.h
│   │   ├── AnomalyIndicator.h
│   │   ├── AnomalyIndicatorFactory.h
│   │   ├── AnomalyIndicatorFactoryImpl.h
│   │   ├── AnomalyIndicatorImpl.cpp
│   │   └── AnomalyIndicatorImpl.h
│   └── model
│       ├── som
│       │   ├── SomAnomalyModel.cpp
│       │   ├── SomAnomalyModel.h
│       │   └── SomAnomalyModelFactory.h
│       ├── training
│       │   ├── engine
│       │   │   ├── AnomalyModelTrainingEngine.h
│       │   │   ├── AnomalyModelTrainingEngineImpl.cpp
│       │   │   └── AnomalyModelTrainingEngineImpl.h
│       │   ├── som
│       │   │   ├── SomAnomalyModelTrainer.cpp
│       │   │   └── SomAnomalyModelTrainer.h
│       │   └── AnomalyModelTrainer.h
│       ├── AnomalyModel.h
│       └── AnomalyModelFactory.h
├── common
├── measurement
├── Application.h
├── Application.cpp
├── DependencyInjector.h
└── main.cpp
```

Let's have one more example with a _data-visualization-web-client_.

This web client's UI consists of the following pages, which all include a common header:

- Dashboards
- Data Explorer
- Alerts

The *Dashboards* page contains a dashboard group selector, dashboard selector, and chart area to display the selected dashboard's charts.
You can select the shown dashboard by first selecting a dashboard group and then a dashboard from that group.

![Dashboards Page](resources/chapter3/images/dashboards_page.png)

The *Data Explorer* page contains selectors for choosing a data source, measure(s), and dimension(s). The page also contains
a chart area to display charts. Using the selectors, a user can change the shown measure(s) and dimension(s) for
the currently selected chart in the chart area.

![Data Explorer Page](resources/chapter3/images/data_explorer_page.png)

Based on the above design, the web client can be divided into the following subdomains:

- Common UI components
  - Chart Area
    - Chart
- Header
- Pages
  - Alerts
  - Dashboards
  - Data Explorer

The source code tree should look like the following:

```
src
├── app
│   ├── common
│   │   └── chartarea
│   │       └── chart
│   ├── header
│   └── pages
│       ├── alerts
│       ├── dashboards
│       │   └── selectors
│       │       ├── dashboardgroup
│       │       └── dashboard
│       └── dataexplorer
│           └── selectors
│               ├── datasource
│               ├── dimension
│               └── measure
├── index.ts
└── store.ts
```

Below is an example of what a single subdomain directory would look like when using React, Redux, and
SCSS modules:

```
src
├── app
│   └── header
│       ├── model
│       │   ├── actions
│       │   │   ├── AbstractHeaderAction.ts
│       │   │   └── NavigateToPageAction.ts
│       │   └── state
│       │       ├── types
│       │       ├── HeaderState.ts
│       │       └── initialHeaderState.ts
│       ├── service
│       ├── view
│       │    ├── navigation
│       │    │   ├── NavigationView.module.scss
│       │    │   └── NavigationView.tsx
│       │    ├── HeaderView.module.scss
│       │    └── HeaderView.tsx
│       └── headerController.ts
├── index.ts
└── store.ts
```

In the above example, we have created two directories for the technical details of the *header* domain: model, service, and view directories. The model directory
contains actions and the state, and the view directory contains the view component, its possible subcomponents, and
CSS definitions. The model's state directory can contain a subdirectory for types
used in the subdomain state. The state directory should always contain the type definition for the subdomain's state and the initial state.
The service directory contains one or more services that use the respective backend services to control the backend model.

## Avoid Comments Principle

> ***Avoid code comments. The only exception is when documenting the public API of a library.***

Comments can be problematic. You cannot trust them 100% because they can be misleading, outdated, or downright wrong. You can only
trust the source code itself. Comments are often entirely unnecessary and only make the code more verbose. Allowing comments can produce
unreadable code containing bad names explained by comments. The code typically also contains long functions where functionality blocks
are described with attached comments instead of refactoring the code by extracting well-named functions. The idea behind this principle is that
when writing comments is disallowed, you are forced to communicate better with the code only.
The following sections describe several ways to avoid writing comments while keeping your code understandable. The following things
can be done to avoid writing comments:

- Name things like classes, functions, and variables properly
  - For example, if you are using a particular algorithm, don't document that algorithm in a comment, but name the respective class/function
    so that it contains the algorithm name. Readers can then google the algorithm by name if unfamiliar with it
- You should not add comments about variable/function types. Use type annotations everywhere
- You don't need to comment that a function can raise an error. Use the function name *try* prefix convention described later in this chapter
- Don't add a comment to a piece of code, but extract a new well-named function
- Keep your functions small. They are easier to understand because they cannot contain too complex logic that could justify a comment
- Don't add as a comment information that can be obtained from the version control system
- Don't comment out the code. Just remove the unused code. The removed code will be available in the version control system forever
- You don't have to comment on a function's logic. Code readers should be able to infer that information from the code itself
  and the related unit tests. Complex code logic and behavior do not usually need comments if you have practiced *test-driven development* and a complete set of well-named unit tests is available.
  You should not comment on what value a function should return with certain input. Create a test case for that.

Code comments often duplicate information already available in the code itself or related tests. This is called information duplication, which should be avoided according to the *don't repeat yourself* (DRY) principle. This principle was introduced in the *Pragmatic Programmer* book by *David Thomas* and *Andrew Hunt*.

Comments for a public API in a library are needed because the library needs API documentation that can be
automatically generated from the comments to avoid situations where API comments and docs are out of sync.
API documentation is usually unnecessary in non-library software components because you can access the API interface,
implementation, and unit tests. The unit tests, for example, specify what the function does in different scenarios. The unit test name
tells the scenario, and the expectations and assertions in the unit test code tell the expected behavior in the particular situation.
API implementation and unit tests are not typically available for library users, and even if they are,
a user should not adhere to them because they are internal details subject to change.

### Name Things Properly

When you name things like a function poorly, you might end up attaching a comment to the function. To avoid writing comments, it is imperative to focus on naming things correctly. When following the _single responsibility principle_
and the _uniform naming principle_, it should be easier to name things correctly and avoid comments. Below is a C++ example of
a function with a comment:

{title: MessageBuffer.h}
```cpp
class MessageBuffer
{
public:
  // Return false if buffer full,
  // true if message written to buffer
  bool write(const std::shared_ptr<Message>& message);
}
```

If we drop the comment, we will have the following code:

{title: MessageBuffer.h}
```cpp
class MessageBuffer
{
public:
  bool write(const std::shared_ptr<Message>& message);
}
```

Dropping the comment alone is not the best solution because some crucial information is now missing. What does that boolean return
value mean? It is not 100% clear. We can assume that returning `true` means the message was successfully written, but
nothing is communicated about returning `false`. We can only assume it is some error, but we are not sure what error.

In addition to removing the comment, we should give a better name for the function and rename it as follows:

{title: MessageBuffer.h}
```cpp
class MessageBuffer
{
public:
  bool writeIfBufferNotFull(
    const std::shared_ptr<Message>& message
  );
}
```

Now, the purpose of the function is clear, and we can be sure of what the boolean return value means. It
means whether the message was written to the buffer. Now we also know why the writing of a message can fail: the
buffer is full. This will give the function caller sufficient information about what to do next. It should probably wait a while so that the buffer reader has enough time to read messages from the buffer
and free up some space.

Below is a real-life example of C++ code where the comment and the function name do not match.

```cpp
  /**
   * @brief Add new counter or get existing, if same labels used already.
   * @param counterName Name of the counter
   * @param help Help text added for counter, if new countername
   * @param labels Specific labels for counter.
   * @return counter pointer used when increasing counter, or nullptr
   *         if metrics not initialized or invalid name or labels
  */
  static prometheus::Counter* addCounter(
    std::string counterName,
    std::string help,
    const std::map<std::string, std::string>& labels
  );
```

In the above example, the function name says that it adds a counter, but the comment says it adds or gets an existing counter.
The real problem is that once someone first reads the function name `addCounter`, they do not necessarily
read the 'brief' in the comments because they immediately understand what the function does after reading its name: it should add a counter.
We could improve the function's name and rename it to `addOrGetExistingCounter` as a solution.

Below is a real-life Java example from a book that I once read:

```java
public interface Mediator {
  // To register an employee
  void register(Person person);

  // To send a message from one employee to another employee
  void connectEmployees(
    Person fromPerson,
    Person toPerson,
    String msg
  );

  // To display currently registered members
  void displayDetail();
}
```

There are three functions in the above example, each of which has a problem.
The first function is registering a person, but the comment says it is registering an employee. So, there is a mismatch
between the comment and the code. In this case, I trust the code over the comment. The correction is to remove the comment
because it does not bring any value. It only causes confusion.

The second function says in the comment that it sends a message from one employee to another. The function name tells
about connecting employees, but the parameters are persons. I assume that a part of the
comment is correct: to send a message from someone to someone else. But once again, I trust the code
more over the comment and assume the message is sent from one person to another. We should remove the comment and rename the function.

In the third function, the comment adds information missing from the function name. The comment also
discusses members, as other parts of the code speak about employees and persons. There are three different
terms used: employee, person, and member. Just one term should be picked. Let's choose the term _person_ and use it systematically.

Below is the refactored version without the comments:

```java
public interface Mediator {
  void register(Person person);

  void send(
    String message,
    Person sender,
    Person recipient
  );

  void displayDetailsOfRegisteredPersons();
}
```

### Single Return Of Named Value At The End Of Function

> ***A function should have a single return statement and return a named value at the end. This allows the code reader to infer the meaning of the return value by looking at the end of the function.*

This principle is relevant for return types that do not convey enough semantic meaning, such as numbers or strings.
Boolean and object type return values often convey semantic meaning.

Consider the following C++ example:

{title: "Metrics.h"}
```cpp
class Metrics
{
public:
  // ...

  static uint32_t addCounter(
    CounterFamily counterFamily,
    const std::map<std::string, std::string>& labels
  );

  static void incrementCounter(
    uint32_t counterIndex,
    size_t incrementAmount
  );

  // addGauge...
  // setGaugeValue...
}
```

What is the return value of the `addCounter` function? Someone might think a comment is needed to describe
the return value because it is unclear what `uint32_t` means. Instead of writing a comment, we can introduce a named value
(= variable/constant) to be returned from the function. The idea behind the named return value is that it communicates the semantics of the return
value without the need for a comment. In C++, you jump from the function declaration to the function definition to see
what the function returns. Below is the implementation for the `addCounter` function:

{title: "Metrics.cpp"}
```cpp
uint32_t Metrics::addCounter(
  const CounterFamily counterFamily,
  const std::map<std::string, std::string>& labels)
{
  uint32_t counterIndex;

  // Perform adding a counter here and
  // set value for the 'counterIndex'

  return counterIndex;
}
```

In the above implementation, we have a single return of a named value at the end of the function. All we have to do is look
at the end of the function and spot the return statement, which should tell us the meaning of the mysterious `uint32_t`
typed return value: It is a counter index. We can spot that the `increaseCounter` function requires a `counterIndex` argument, and this establishes a connection between calling the `addCounter` function first, storing the returned counter index, and later using that stored counter index in calls to the `increaseCounter` function.

### Return Type Aliasing

In the previous example, there was the mysterious return value of type `uint32_t` in the `addCounter` function. We learned how
introducing a named value returned at the end of the function helped to communicate the semantics of the return value. But there is
an even better way to communicate the semantics of a return value. Many languages like C++ and TypeScript offer type aliasing that
can be used to communicate the return value semantics. Below is a C++ example where we introduce a `CounterIndex` type alias
for the `uint32_t` type:

{title: "Metrics.h_"}
```cpp
class Metrics
{
public:
  using CounterIndex = uint32_t;

  // ...

  static CounterIndex addCounter(
    CounterFamily counterFamily,
    const std::map<std::string, std::string>& labels
  );

  static void incrementCounter(
    CounterIndex counterIndex,
    size_t incrementAmount
  );
}
```

Here is the same example in TypeScript:

{title: "Metrics.ts"}
```ts
export type CounterIndex = number;

export default class Metrics {
  // ...

 static addCounter(
    counterFamily: CounterFamily,
    labels: Record<string, string>
  ): CounterIndex;

  static incrementCounter(
    counterIndex: CounterIndex,
    incrementAmount: number
  ): void;
}
```

Some languages, like Java, don't have type aliases. In that case, you can introduce a wrapper class for the returned value. Here is the same example in Java:

{title: "CounterIndex.java"}
```java
public class CounterIndex {
  private final int value;

  public CounterIndex(final int value) {
    this.value = value;
  }

  public int get() {
    return value;
  }
}
```

{title: "Metrics.java"}
```java
public final class Metrics {
  // ...

  public static CounterIndex addCounter(
    final CounterFamily counterFamily,
    final Map<String, String> labels
  ) {
    // ...
  }

  public static void incrementCounter(
    CounterIndex counterIndex,
    double incrementAmount
  ) {
    // ...
  }
}
```

We can improve the above example. The `CounterIndex` class could be derived from a generic `Value` class:

```java
public class Value<T> {
  private final T value;

  public Value(final T value) {
    this.value = value;
  }

  public T get() {
    return value;
  }
}


public class CounterIndex extends Value<Integer> {
  // ...
}
```

We can improve the above metrics example a lot. First, we should avoid the primitive type obsession. We should not be returning an index
from the `addCounter` method, but we should rename the method as `createCounter` and return an instance of a `Counter` class from
the method. Then we should make the example more object-oriented by moving the `incrementCounter` method to the `Counter` class
and naming it just `increment`. Also, the name of the `Metrics` class should be changed to `MetricFactory`. Finally,
we should make the `MetricFactory` class a singleton instead of containing static methods.

### Extract Constant for Boolean Expression

By extracting a constant for a boolean expression, we can eliminate comments. Below is an example where a comment is written after an if-statement and its boolean expression:

{title: "MessageBuffer.cpp"}
```cpp
bool MessageBuffer::writeIfBufferNotFull(
  const std::shared_ptr<Message>& message
) {
  bool messageWasWritten{false};

  if (m_messages.size() < m_maxBufferSize)
  {
    // Buffer is not full
    m_messages.push_back(message);
    messageWasWritten = true;
  }

  return messageWasWritten;
}
```

By introducing a constant to be used in the "buffer is full" check, we can get rid of the "Buffer is not full" comment:

{title: "MessageBuffer.cpp"}
```cpp
bool MessageBuffer::writeIfBufferNotFull(
  const std::shared_ptr<Message> message
) {
  bool messageWasWritten{false};

  const bool bufferIsNotFull =
    m_messages.size() < m_maxBufferSize;

  if (bufferIsNotFull)
  {
    m_messages.push_back(message);
    messageWasWritten = true;
  }

  return messageWasWritten;
}
```

When writing comparison expressions, remember to write the comparison so that it is fluent to read:

```ts
# Wrong, not fluent to read
if ('John' === customerName) {
  // ...
}

# Correct
if (customerName === 'John') {
  // ...
}

# Wrong
bufferIsNotFull = maxLength > messages.length;

# Correct
bufferIsNotFull = messages.length < maxLength;
```

You should also have matching names for the variables being compared:

```ts
# Correct
bufferIsNotFull = messages.length < maxLength;

# Incorrect
# Left side of comparison speaks about length and
# right side speaks about size
bufferIsNotFull = messages.length < maxSize;
```

### Extract Named Constant or Enumerated Type

If you encounter a [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)) in your code, you should introduce either a named constant or an enumerated type (enum) for that value.
In the below example, we are returning two magic numbers, 0 and 1:

{title: "main.cpp"}
```cpp
int main()
{
  Application application;

  if (application.run())
  {
    // Application was run successfully
    return 0;
  }

  // Exit code: failure
  return 1;
}
```

Let's introduce an enumerated type, `ExitCode,` and use it instead of magic numbers:

{title: "main.cpp"}
```
enum class ExitCode
{
  Success = 0,
  Failure = 1
};

int main()
{
  Application application;
  const bool appWasRun = application.run();

  return static_cast<int>(
    appWasRun ? ExitCode::Success : ExitCode::Failure
  );
}
```

It is now easy to add more exit codes with descriptive names later if needed.

### Extract Function

If you are planning to write a comment above a piece of code, you should extract that piece of code to a new function. When you extract a well-named function, you don't need to write that comment. The name
of the newly extracted function serves as documentation. Below is an example with some commented code:

{title: "MessageBuffer.cpp"}
```cpp
void MessageBuffer::writeFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  if (m_messages.size() + messages.size() <= m_maxBufferSize)
  {
    // All messages fit in buffer
    m_messages.insert(m_messages.end(),
                      messages.begin(),
                      messages.end());

    messages.clear();
  }
  else
  {
    // All messages do not fit, write only messages that fit
    const auto messagesEnd = messages.begin() +
                             m_maxBufferSize -
                             m_messages.size();

    m_messages.insert(m_messages.end(),
                      messages.begin(),
                      messagesEnd);

    messages.erase(messages.begin(), messagesEnd);
  }
}
```

Here is the same code with comments refactored out by extracting two new methods:

{title: "MessageBuffer.cpp"}
```cpp
void MessageBuffer::writeFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  const bool allMessagesFit = m_messages.size() +
                              messages.size() <= m_maxBufferSize;

  if (allMessagesFit)
  {
    writeAll(messages)
  }
  else
  {
    writeOnlyFitting(messages);
  }
}

void MessageBuffer::writeAll(
  std::deque<std::shared_ptr<Message>>& messages
) {
  m_messages.insert(m_messages.end(),
                    messages.begin(),
                    messages.end());

  messages.clear();
}

void MessageBuffer::writeOnlyFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  const auto messageCountThatFit = m_maxBufferSize -
                                   m_messages.size();

  const auto messagesEnd = messages.begin() +
                           messageCountThatFit;

  m_messages.insert(m_messages.end(),
                    messages.begin(),
                    messagesEnd);

  messages.erase(messages.begin(), messagesEnd);
}
```

### Avoid Comments for Regular Expression

When you have a complex regular expression, you might be tempted to attach a comment to it to explain the meaning
of it. But there is an alternative way. You can split the complex regular expression into well-named parts and construct the final regular expression from those well-named parts. For example, suppose you must create a regular expression to validate phone numbers in the international format. In that case, you can split the regular expression into
the following parts: plus sign, country code, area code, and the rest of the phone number (local number). You can define
the regular expression using the parts: `intlPhoneNbrRegExpr = plusSign + countryCode + areaCode +
localNumber`.

### Name Anonymous Function

Anonymous functions are common in functional programming, e.g., when using
algorithms like _forEach_, _map_, _filter_, and _reduce_. When an anonymous function is long or complex, you should give it a descriptive name and split it into multiple functions
if it is too long. This way, you can eliminate comments.

In the below TypeScript example, we have an anonymous function with a comment:

```ts
// ...

fs.watchFile('/etc/config/LOG_LEVEL', () => {
  // Update new log level
  try {
    const newLogLevel = fs.readFileSync('/etc/config/LOG_LEVEL',
                                        'utf-8'}).trim();
    tryValidateLogLevel(newLogLevel);
    process.env.LOG_LEVEL = newLogLevel;
  } catch (error) {
    // ...
  }
});
```

We can refactor the above example so that the comment is removed and
the anonymous function is given a name:

```ts
function updateNewLogLevel() {
  try {
    const newLogLevel = fs.readFileSync('/etc/config/LOG_LEVEL',
                                        'utf-8'}).trim();
    tryValidateLogLevel(newLogLevel);
    process.env.LOG_LEVEL = newLogLevel;
  } catch (error) {
    // ...
  }
}

fs.watchFile('/etc/config/LOG_LEVEL', updateNewLogLevel);
```

### Avoiding Comments in Bash Shell Scripts

Many programmers, myself included, don't enjoy the mysterious syntax of Linux shell commands and scripts.
Even the syntax of the simplest expressions can be hard to understand and remember if you don't regularly work
with scripts and commands. Of course, the best thing is to avoid writing complex Linux shell scripts and
use a proper programming language like Python instead. But sometimes, performing some actions
using a shell script is easier. Because the syntax and commands in shell scripts can be hard to understand, many developers tend to
solve the problem by adding comments to scripts.

Next, alternative ways to make scripts more understandable
without comments are presented. Let's consider the below example from one real-life script I have bumped into:

```bash
create_network() {
  #create only if not existing yet
  if [[ -z "$(docker network ls | grep $DOCKER_NETWORK_NAME )" ]];
  then
    echo Creating $DOCKER_NETWORK_NAME
    docker network create $DOCKER_NETWORK_NAME
  else
    echo Network $DOCKER_NETWORK_NAME already exists
  fi
}
```

Below is the same example with the following changes:

- The comment was removed, and the earlier commented expression was moved to a well-named function
- The negation in the expression was removed, and the contents of the *then* and *else* branches were swapped
- Variable names were made camel case to enhance readability. All-caps names are harder to read.

```bash
dockerNetworkExists() { [[ -n "$(docker network ls | grep $1 )" ]]; }

createDockerNetwork() {
  if dockerNetworkExists $networkName; then
    echo Docker network $networkName already exists
  else
    echo Creating Docker network $networkName
    docker network create $networkName
  fi
}
```

If your script accepts arguments, give the arguments proper names, for example:

```bash
dataFilePathName=$1
schemaFilePathName=$2
```

The script reader does not have to remember what `$1` or `$2` means, and you don't have to insert
any comments to clarify the meaning of the arguments.

If you have a complex command in a Bash shell script, you should not attach a comment to it but extract a function
with a proper name to describe the command.

The below example contains a comment:

```bash
# Update version in Helm Chart.yaml file
sed -i "s/^version:.*/version: $VERSION/g" helm/service/Chart.yaml
```

Here is the above example refactored to contain a function and a call to it:

```bash
updateHelmChartVersionInChartYamlFile() {
  sed -i "s/^version:.*/version: $1/g" helm/service/Chart.yaml
}

updateHelmChartVersionInChartYamlFile $version
```

Here is another example:

```bash
getFileLongestLineLength() {
  echo $(awk '{ if (length($0) > max) max = length($0) } END { print max }' $1)
}

configFileLongestLineLength = $(getFileLongestLineLength $configFilePathName)
```

## Function Single Return Principle

> ***Prefer a single return statement at the end of a function to clearly communicate the return value's meaning and make refactoring the function easier.***

A single return statement with a named value at the end of a function clearly communicates the return value semantics
if the return value type does not directly communicate it. For example, if you return a value of a primitive
type like an integer or string from a function, it is not necessarily 100% clear what the return value means. But when you return a named value at the end of the
function, the name of the returned variable communicates the semantics.

You might think that being unable to return a value in the middle of a function would make
the function less readable because of lots of nested if-statements. This is possible, but one should remember that a function should be small. Aim to have a maximum of 5-9 lines of statements
in a single function. Following that rule, you never have _a hell of nested if-statements_ inside
a single function.

Having a single return statement at the end of a function makes refactoring the function easier. You can use automated
refactoring tools provided by your IDE. It is always harder to extract a new function from code containing
a return statement. The same applies to loops with a _break_ or _continue_ statement. It is easier to refactor code
inside a loop that does not contain a break or continue statement.

In some cases, returning a single value at the end of a function makes the code more straightforward and requires fewer lines of code.

Below is an example of a function with two return locations:

{title: "TransformThread.cpp"}
```cpp
bool TransformThread::transform(
  const std::shared_ptr<InputMessage>& inputMessage
) {
  auto outputMessage = m_outputMessagePool->acquireMessage();
  bool messageIsFilteredIn;

  const bool messageWasTransformed =
    m_messageTransformer->transform(inputMessage,
                                   outputMessage,
                                   messageIsFilteredIn);

  if (messageWasTransformed && messageIsFilteredIn)
  {
    m_outputMessages.push_back(outputMessage);
  }
  else
  {
    m_outputMessagePool->returnMessage(outputMessage);

    if (!messageWasTransformed)
    {
        return false;
    }
  }

  return true;
}
```

When analyzing the above function, we notice that it transforms an input message into an output message.
We can conclude that the function returns _true_ on successful message transformation. We can shorten the function by refactoring
it to contain only one return statement. After refactoring, it is 100% clear what the function return value means.

{title: "TransformThread.cpp"}
```cpp
bool TransformThread::transform(
  const std::shared_ptr<InputMessage>& inputMessage
) {
  auto outputMessage = m_outputMessagePool->acquireMessage();
  bool messageIsFilteredIn;

  const bool messageWasTransformed =
      m_messageTransformer->transform(inputMessage,
                                      outputMessage,
                                      messageIsFilteredIn);

  if (messageWasTransformed && messageIsFilteredIn)
  {
    m_outputMessages.push_back(outputMessage);
  }
  else
  {
    m_outputMessagePool->return(outputMessage);
  }

  return messageWasTransformed;
}
```

As an exception to this rule, you can have multiple return statements in a function when the function has optimal length and would become too long if it is refactored to contain a single return statement.
Additionally, it is required that the semantic meaning of the return value is evident from the function name or the return type of the function. This is usually true if the return value is a boolean value or
an object. You can use so-called [guard clauses](https://en.wikipedia.org/wiki/Guard_(computer_science)) at the beginning of the function. These guard clauses are if-statements that can return early from the function if a
certain condition is met. You can have multiple guard clauses. Here is a Java example of a guard clause:

```java
public Optional<Session> getSession(final String userName){
    if (userName.isEmpty()) {
        return Optional.empty();
    }

    // Rest of the method code follows here...
}

Below is an example of a function with multiple return statements. It is also clear from the function name what the return value means. Also, the length of the function is optimal: seven statements.

```ts
private areEqual(
  iterator: MyIterator<T>,
  anotherIterator: MyIterator<T>
): boolean {
  while (iterator.hasNextElement()) {
    if (anotherIterator.hasNextElement()) {
      if (iterator.getNextElement() !==
          anotherIterator.getNextElement()) {
       return false;
      }
    } else {
      return false;
    }
  }

  return true;
}
```

If we refactored the above code to contain a single return statement, the code would become too long (10 statements) to fit in one function, as shown below. In this case, we would prefer the above code over the code below.

```ts
private areEqual(
  iterator: MyIterator<T>,
  anotherIterator: MyIterator<T>
): boolean {
  let areEqual = true;

  while (iterator.hasNextElement()) {
    if (anotherIterator.hasNextElement()) {
      if (iterator.getNextElement() !==
          anotherIterator.getNextElement()) {
       areEqual = false;
       break;
      }
    } else {
      areEqual = false;
      break;
    }
  }

  return areEqual;
}
```

As the second exception to this rule, you can use multiple return locations in a factory because you know
from the factory name what type of objects it creates. Below is an example factory with multiple return statements:

```cpp
enum class CarType
{
  Audi,
  Bmw,
  MercedesBenz
};

class Car
{
  // ...
};

class Audi : public Car
{
  // ...
};

class Bmw : public Car
{
  // ...
};

class MercedesBenz : public Car
{
  // ...
};

class CarFactory
{
public:
  std::shared_ptr<Car> createCar(const CarType carType)
  {
    switch(carType)
    {
      case CarType::Audi:
        return std::make_shared<Audi>();
      case CarType::Bmw:
        return std::make_shared<Bmw>();
      case CarType::MercedesBenz:
        return std::make_shared<MercedesBenz>();
      default:
        throw std::invalid_argument("Unknown car type");
    }
  }
};
```

## Prefer a Statically Typed Language for Production Code Principle

> ***Prefer a statically typed language when implementing production software. You can use an untyped language like Python for non-production code like integration, end-to-end and automated non-functional tests. And you can use Bash shell scripting for small scripts.

You can manage with a trivial software component without types, but when it grows bigger and more people are involved, the benefits of static typing become evident.

Let's analyze what potential problems using an untyped language might incur:

- Function arguments might be given in the wrong order
- Function argument might be given with the wrong type
- Function return value type might be misunderstood
- Refactoring code is more difficult
- Forced to write public API comments to describe function signatures
- Type errors are not necessarily found in testing

### Function Arguments Might Be Given in Wrong Order

When not using type annotations for functions, you can accidentally give function arguments in the wrong order.
When you use type annotations, this kind of error is less common. Modern IDEs can display inlay hints for parameters in a function call. This is a feature you should consider enabling in your IDE.
Those parameter hints might reveal cases where arguments for a function are not given in the correct order.

### Function Argument Might Be Given with Wrong Type

You can give a function argument with the wrong type when type annotations are not used. For example,
a function requires a string representation of a number, but you provide a number. Correctly naming function arguments can help. Instead of
naming a string argument, *amount*, the argument should be named as *amountString* or *amountAsString*.

### Function Return Value Type Might Be Misunderstood

Determining the function return value type can be difficult. It is not necessarily 100% clear from the name of the function. For example,
if you have a function named `getValue`, the return value type is not 100% clear. It might be apparent only if you know the context of the function well. As an improvement,
the function should be appropriately named, for example: `getValueAsString()`, if the returned value is always a string. If the return value type is unclear
when looking at the function name, you must analyze the function's source code to determine the return value
type. That is unnecessary and error-prone manual work that can be avoided using function return type annotations.

### Refactoring Code Is More Difficult

Refactoring code is usually more difficult if you don't have type annotations. But when you have type annotations and
make a change to, e.g., a function argument type, you will get type check errors in parts of code where this function
is called. Then, it is easy to refactor those parts. But if you didn't have type annotations and made this same change, you
would have to manually find all the places where a change is needed, which is clearly more error-prone.

### Forced to Write Public API Comments

You might be forced to document a public API using comments when not using type annotations.
That is additional work that could be avoided by using type annotations. Writing API documentation with
comments is error-prone. You can accidentally write wrong information in the API documentation or
forget to update the documentation when you make changes to the API code itself. Similarly, the
API documentation readers can make mistakes. They might not read the API documentation at all. Or they have read it earlier but later misremembered it.

### Type Errors Are Not Found in Testing

This is the biggest problem. You might think that if you have mistakes in your code related to having correct function arguments
with the correct types, testing will reveal those mistakes. This is typically a wrong assumption.
Unit tests won't find the issues because you mock other classes and their methods. You can only find
the issues in integration testing when you integrate the software component (i.e., test functions calling
other real functions instead of mocks). According to the testing pyramid, integration tests only cover a subset of the codebase,
less than unit tests. Depending on the code coverage of the integration tests, some function argument order
or argument/return value type correctness issues may be left untested and escape to production.

## Refactoring Principle

> ***You cannot write the perfect code on the first try, so you should always reserve some time for future refactoring.***

You must refactor even if you write code for a new software component. Refactoring is not related
to legacy codebases only. If you don't refactor, you let technical debt grow in the software. The main idea
behind refactoring is that no one can write the perfect code on the first try. Refactoring means that you
change code without changing the actual functionality. After refactoring, most tests should still
pass, the code is organized differently, and you have a better object-oriented design and improved naming of things.
Refactoring does not usually affect integration tests but can affect unit tests depending on the type and scale
of refactoring. Keep this in mind when estimating refactoring effort. When you practice test-driven development (TDD), you
are bound to refactor. Refactoring is a practice built into the TDD process. In TDD, the final function implementation results from a series of
refactorings. This is one of the biggest benefits of TDD. We will discuss TDD more in the next chapter.

Software developers don't necessarily reserve any or enough time for refactoring when they plan things.
When we provide work estimates for epics, features, and user
stories, we should be conscious of the need to refactor and add some extra time to our initial work estimates
(which don't include refactoring). When you use TDD, you start automatically reserving some time for refactoring because refactoring is an integral part of the TDD process.
Refactoring is work that is not necessarily understood clearly by the management.
The management should support the need to refactor even if it does not bring clear added
value to an end user. But it brings value by not letting the codebase rot and removing technical debt. If you have
software with lots of accumulated technical debt, developing new features and maintaining the software is costly. Also,
the quality of the software is lower, which can manifest in several bugs and lowered customer satisfaction.

Below is a list of the most common [code smells](https://en.wikipedia.org/wiki/Code_smell) and refactoring techniques to resolve them:

| Code Smell                                 | Refactoring Solution                   |
|--------------------------------------------|----------------------------------------|
| Non-descriptive name                       | Rename                                 |
| Long method                                | Extract method                         |
| Large class                                | Extract class                          |
| Complex expression                         | Extract constant                       |
| Long switch-case or if/elif/else statement | Replace conditionals with polymorphism |
| Long parameter list                        | Introduce parameter object             |
| Shotgun surgery                            | Replace conditionals with polymorphism |
| Negated boolean condition                  | Invert if-statement                    |
| Anemic object                              | Creating rich object                   |

There are other refactoring techniques, but the ones explained here are the most relevant and valuable. You can
find other refactoring techniques in *Martin Fowler*'s book *Refactoring*. Some of the refactorings presented in that book
are pretty self-evident for experienced OOP practitioners; others are also handled in this book but scattered around and
described as part of different principles and patterns, and some refactorings are primarily for legacy code only.
You don't need them when writing new code with appropriate linter settings active. One example of such a refactoring is "Remove Assignments to Parameters".
You don't need that when writing new code because you should have a linting rule that disallows assignments to parameters.

### Rename

This is probably the single most used refactoring technique. You often don't get the names right on the first try
and need to do renaming. Modern IDEs offer tools that help rename things in the code: interfaces, classes,
functions, and variables. The IDE's renaming functionality is always better than the plain old
search-and-replace method. When using the search-and-replace method, you can accidentally rename something you do not want to be renamed or don't rename something that should have been renamed.

### Extract Method

This is probably the second most used refactoring technique. When you implement a public method of a class, the method
quickly grows in the number of code lines. A function should contain a maximum of 5-9 statements to keep it readable and understandable.
When a public method is too long, you should extract one or more private methods and call these private methods
from the public method. Every modern IDE has an *extract method* refactoring tool that allows you to extract
private methods easily. Select the code lines you want to extract to a new method and press the IDE's shortcut key
for the *extract method* functionality. Then, give a descriptive name for the extracted method, and you are
done. (An additional thing you can do is organize the arguments for the extracted method in better order
before completing the extraction in the IDE). In some cases, the refactoring is not automatic. For example, if the code to be extracted contains a *return*, *break*,
or *continue* statement, that affects the execution flow of the function (causing multiple return points). To keep
your code refactorable, avoid using *break* and *continue* statements and have only a single return statement
at the end of the function.

### Extract Class

This refactoring technique is used to make a large class smaller. A large class contains several hundreds of
lines of code or tens of methods. To make a class smaller, you need to extract one or more behavioral classes from
it and use them in the original class. This refactoring technique allows you to use the *strategy pattern* described
in the previous chapter. Let's have a simple example with a `Bird` class, which we assume to be large:

```java
public class Bird {
  public void move() {
    // This method uses the below helper methods
  }

  public void makeSound() {
    // This method uses the below helper methods
  }

  // Possibly some other public methods ...

  private void moveHelper1() {
    // ...
  }

  // ...

  private void moveHelper4() {
    // ...
  }


  private void makeSoundHelper1() {
    // ...
  }

  // ...

  private void makeSoundHelper4() {
    // ...
  }
}
```

To make the above class smaller, we can extract two behavioral classes: `BirdMover` and `BirdSoundMaker`.
After refactoring, we have the following classes:

```java
public interface BirdMover {
  void move();
}


public class BirdMoverImpl implements BirdMover {
  public void move() {
    // Use the below helper methods ...
  }

  private void moveHelper1() {
    // ...
  }

  // ...

  private void moveHelper4() {
    // ...
  }
}


public interface BirdSoundMaker {
  void makeSound();
}


public class BirdSoundMakerImpl implements BirdSoundMaker {
  public void makeSound() {
    // Use the below helper methods ...
  }

  private void makeSoundHelper1() {
    // ...
  }

  // ...

  private void makeSoundHelper4() {
    // ...
  }
}


public class Bird {
  private final BirdMover mover;
  private final BirdSoundMaker soundMaker;

  public Bird(final BirdMover mover, final BirdSoundMaker soundMaker) {
    this.mover = mover;
    this.soundMaker = soundMaker;
  }

  public void move() {
    // Call mover.move()
  }

  public void makeSound() {
    // Call soundMaker.makeSound()
  }

  // Possibly some other public methods ...
}
```

The above solution allows us to use the *strategy pattern*. We can introduce new classes that implement the `BirdMover` and `BirdSoundMaker` protocols and supply them to the `Bird` class constructor.
We can now modify the behavior of the `Bird` class using the *open-closed principle*.

### Extract Constant

If you have a complex expression (boolean or numeric), assign the value of the expression to a constant.
The name of the constant conveys information about the expression. Below is a JavaScript example where we make the if-statements read better
by extracting expressions to constants:

```js
// ...

if (dataSourceSelectorIsOpen &&
    measureSelectorIsOpen &&
    dimensionSelectorIsOpen
) {
  dataSourceSelectorContentElem.style.height =
    `${0.2 * availableHeight}px`;

  measureSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;

  dimensionSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
} else if (!dataSourceSelectorIsOpen &&
           !measureSelectorIsOpen &&
           dimensionSelectorIsOpen
) {
    dimensionSelectorContentElem.style.height
      = `${availableHeight}px`;
}
```

Let's extract constants:

```js
// ...

const allSelectorsAreOpen = dataSourceSelectorIsOpen &&
                            measureSelectorIsOpen &&
                            dimensionSelectorIsOpen;

const onlyDimensionSelectorIsOpen =
    !dataSourceSelectorIsOpen &&
    !measureSelectorIsOpen &&
    dimensionSelectorIsOpen;

if (allSelectorsAreOpen) {
  dataSourceSelectorContentElem.style.height =
    `${0.2 * availableHeight}px`;

  measureSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;

  dimensionSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
} else if (onlyDimensionSelectorIsOpen) {
  dimensionSelectorContentElem.style.height =
    `${availableHeight}px`;
}
```

Below is an example in C++ where we return a boolean expression:

```cpp
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherFieldSchema
) const
{
  return m_type == otherFieldSchema->getType() &&
         m_name.substr(m_name.find_first_of('.') + 1U) ==
         otherFieldSchema->getName().substr(
          otherFieldSchema->getName().find_first_of('.') + 1U);
}
```

It can be challenging to understand what the boolean expression means.
We could improve the function by adding a comment: (We assume
that each field name has a root namespace that cannot contain a dot character)

```cpp
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherFieldSchema
) const
{
  // Field schemas are equal if field types are equal and
  // field names without the root namespace are equal
  return m_type == otherFieldSchema->getType() &&
         m_name.substr(m_name.find_first_of('.') + 1U) ==
         otherFieldSchema->getName().substr(
          otherFieldSchema->getName().find_first_of('.') + 1U);
}
```

However, we should not write comments because comments are never 100% trustworthy.
It is possible that a comment and the related code are not in synchrony: someone has changed the function without updating the comment or modified only the comment but
did not change the function.
Let's refactor the above example by removing the comment and extracting multiple constants.
The below function is longer than the original, but it is, of course, more readable. If you look
at the last two statements of the method, you can understand in what case two field schemas
are equal. It should be the compiler's job to make the below longer version of the function as performant as the original
function.

```cpp
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherFieldSchema
) const
{
  const auto fieldNameWithoutRootNamespace =
    m_name.substr(m_name.find_first_of('.') + 1U);

  const auto otherFieldName = otherFieldSchema->getName();

  const auto otherFieldNameWithoutRootNamespace =
    otherFieldName.substr(otherFieldName.find_first_of('.') + 1U);

  const bool fieldTypesAndNamesWithoutRootNsAreEqual =
    m_type == otherFieldSchema->getType() &&
    fieldNameWithoutRootNamespace == otherFieldNameWithoutRootNamespace;

  return fieldTypesAndNamesWithoutRootNsAreEqual;
}
```

### Replace Conditionals with Polymorphism

Suppose you encounter a sizeable match-case statement or if/else-structure in your code (not considering
code in factories). This means that your software component does not have a proper object-oriented design.
You should replace the conditionals with polymorphism. When you introduce proper OOD
in your software component, you move the functionality from a match statement's case branches to different
classes that implement a particular interface. And similarly, you move the code from if and elif-statements
to different classes that implement a specific interface. This way, you can eliminate the switch-case and if/else-statements
and replace them with polymorphic method calls. Crafting proper OOD helps in creating a software component with classes
that have high cohesion. The functionality of the classes is no longer scattered around in the codebase.

Below is a TypeScript example of non-object-oriented design:

```ts
function doSomethingWith(chart: Chart) {
  if (chart.getType() === 'column') {
    // do this
  } else if (chart.getType() === 'pie') {
    // do that
  } else if (chart.getType() === 'geographic-map') {
    // do a third thing
  }
}
```

Let's replace the above conditionals with polymorphism:

```ts
interface Chart {
  doSomething(...): void;
}

class ColumnChart implements Chart {
  doSomething(...): void {
    // do this
  }
}

class PieChart implements Chart {
  doSomething(...): void {
    // do that
  }
}

class GeographicMapChart implements Chart {
  doSomething(...): void {
    // do a third thing
  }
}

function doSomethingWith(chart: Chart) {
  chart.doSomething();
}
```

Suppose you are implementing a data visualization application and have many places in your code where you check the chart type and need to introduce a new chart type.
It could mean you must add a new *case* or *elif* statement in many places in the code. This approach is very error-prone.
It is called *shotgun surgery* because you need to find all the places in the codebase where the code needs to be modified.
What you should do is conduct proper object-oriented design and introduce a new chart class containing the new functionality
instead of introducing that new functionality by modifying code in multiple places.

### Introduce Parameter Object

If you have more than 5-7 parameters for a function, you should introduce a parameter object to reduce
the number of parameters to keep the function signature more readable. Below is an example constructor
with too many parameters:

{title: "KafkaConsumer.java"}
```java
public class KafkaConsumer {
  public KafkaConsumer(
    final List<String> brokers,
    final List<String> topics,
    final List<String> extraConfigEntries,
    final boolean tlsIsUsed,
    final boolean certShouldBeVerified,
    final String caFilePathName,
    final String certFilePathName,
    final String keyFilePathName)
  {
    // ...
  }
}
```

Let's group the Transport Layer Security (TLS) related parameters to a parameter class named `TlsOptions`:

{title: "TlsOptions.java"}
```java
public class TlsOptions {
  public TlsOptions(
    final boolean tlsIsUsed,
    final boolean certShouldBeVerified,
    final String caFilePathName,
    final String certFilePathName,
    final String keyFilePathName
  ) {
    // ...
  }
}
```

Now we can modify the `KafkaConsumer` constructor to utilize the `TlsOptions` parameter class:

{title: "KafkaConsumer.java"}
```java
public class KafkaConsumer {
  public KafkaConsumer(
    final List<String> brokers,
    final List<String> topics,
    final List<String> extraConfigEntries,
    final TlsOptions tlsOptions
  ) {
    // ...
  }
}
```

### Invert If-Statement

This is a refactoring that a modern IDE can do for you.

Below is a Python example with a negated boolean expression in the if-statement condition.
Notice how difficult the boolean expression reads: `host_mount_folder is not None`. It is a double-negative statement
and thus can be difficult to read.

```python
import os


def get_behave_test_folder(relative_test_folder = ""):
  host_mount_folder = os.environ.get("HOST_MOUNT_FOLDER")

  if host_mount_folder is not None:
    final_host_mount_folder = host_mount_folder
    if host_mount_folder.startswith("/mnt/c/"):
      final_host_mount_folder = host_mount_folder.replace("/mnt/c/", \
                                                          "/c/", 1)

    behave_test_folder = final_host_mount_folder + "/" + \
                         relative_test_folder
  else:
    behave_test_folder = os.getcwd()

  return behave_test_folder
```

Let's refactor the above code so that the if and else statements are inverted:

```python
def get_behave_test_folder(relative_test_folder = ""):
  host_mount_folder = os.environ.get("HOST_MOUNT_FOLDER")

  if host_mount_folder is None:
    behave_test_folder = os.getcwd()
  else:
    final_host_mount_folder = host_mount_folder
    if host_mount_folder.startswith("/mnt/c/"):
      final_host_mount_folder = host_mount_folder.replace("/mnt/c/", \
                                                          "/c/", 1)
    behave_test_folder = final_host_mount_folder + "/" + \
                         relative_test_folder

  return behave_test_folder
```

Below is another example in C++:

```cpp
if (somePointer != nullptr)
{
  // Do thing 1
}
else
{
  // Do thing 2
}
```

We should not have a negation in the if-statement's condition. Let's refactor the above example:

```cpp
if (somePointer == nullptr)
{
  // Do thing 2
}
else
{
  // Do thing 1
}
```

### Creating Rich Object

An object can be a so-called [anemic object](https://en.wikipedia.org/wiki/Anemic_domain_model) with little or no behavior.
The object class might only contain attributes and getters and setters for them, making it a kind of data class only.
Sometimes, this is okay if there is no business
logic related to the object, but many times, there exists some business logic, but that logic is not implemented in the anemic object
class itself but in other places in the code. This kind of software "design" (a better term is lack of design) is deemed to be problematic
when you need to change the anemic object class. You might need to make changes to various unrelated places in the code. Making all these changes is manual and error-prone work.
Making those changes is called [shotgun surgery](https://en.wikipedia.org/wiki/Shotgun_surgery). What you should do is make an anemic object a rich object.
This is done by moving behavior from other classes to the anemic class, making it a rich class. A rich class typically has attributes and behavior but
it lacks getters and setters to enforce proper encapsulation of the object state.

Let's have an example of a anemic class:

```java
public class Rectangle {
  private float width;
  private float height;

  public Rectangle(final float width, final float height) {
    this.width = width;
    this.height = height;
  }

  public float getWidth() {
    return width;
  }


  public float getHeight() {
    return height;
  }

  public void setWidth(final float width) {
    this.width = width;
  }

  public void setHeight(final float height) {
    this.height = height;
  }
}


public class Drawer {
  // Possible other methods ...

  public void drawRectangle(final Rectangle rectangle) {
    // ...
  }
}


public class Calculator {
  // Possible other methods

  public float calcRectArea(final Rectangle rectangle) {
    // ...
  }

  public float calcRectPerimeter(final Rectangle rectangle) {
    // ...
  }
}

public class Sizer {
  // Possible other methods

  public void increaseRectWidth(
    final Rectangle rectangle,
    final float percentage
  ) {
    // ...
  }


 public void increaseRectHeight(
    final Rectangle rectangle,
    final float percentage
 ) {
   // ...
 }
}
```

What we should do is to make the `Rectangle` objects rich objects by moving functionality from various classes
into the `Rectangle class` and removing the getters and setters:

```java
public class Rectangle {
  private float width;
  private float height;

  public Rectangle(final float width, final float height) {
    this.width = width;
    this.height = height;
  }

  public void draw() {
    // Implement drawing here ...
  }

  public float calculateArea() {
    // Calculate area here ...
  }

  public float calculatePerimeter() {
    // Calculate perimeter here ...
  }

  public void increaseWidth(final float percentage) {
    // Increase width here ...
  }

  public void increaseHeight(final float percentage) {
    // Increase height here ...
  }
}
```

Let's imagine that the methods added to the `Rectangle` class are large, and the whole class becomes too large.
In that case, we can use the *bridge pattern* and refactor the classes as shown below. We still have a rich `Rectangle` class
with attached behavior, and we do not need any getters or setters because we are not passing the `this` to any outside
object of the `Rectangle` class.

```java
public interface Drawer {
  void drawRectangle(final float width, final float height);

  // Possible other methods ...
}


public interface Calculator {
  float calcRectArea(final float width, final float height);
  float calcRectPerimeter(final float width, final float height);

  // Possible other methods ...
}


public interface Sizer {
  float increase(final float length, final float percentage);

  // Possible other methods ...
}


public class Rectangle {
  private float width;
  private float height;
  private final Drawer drawer;
  private final Calculator calculator;
  private final Sizer sizer;

  public Rectangle(
    final float width,
    final float height,
    final Drawer drawer,
    final Calculator calculator,
    final Sizer sizer
  ) {
    this.width = width;
    this.height = height;
    this.drawer = drawer;
    this.calculator = calculator;
    this.sizer = sizer;
  }

  public void draw() {
    drawer.drawRectangle(width, height);
  }

  public float calculateArea() {
    return calculator.calcRectArea(width, height);
  }

  public float calculatePerimeter() {
    return calculator.calcRectPerimeter(width, height);
  }

  public void increaseWidth(final float percentage) {
    width = sizer.increase(width, percentage);
  }

  public void increaseHeight(final float percentage) {
    height = sizer.increase(height, percentage);
  }
}
```

You can see from the above code that we no longer need to perform *shotgun surgery* if we need to change the `Rectangle` class. For example, let's say that our rectangles should always have a height double the width. We can refactor the `Rectangle` class to the following:

```java
public class Rectangle {
  private float width;
  private float height;
  private final Drawer drawer;
  private final Calculator calculator;
  private final Sizer sizer;

  public Rectangle(
    final float width,
    final Drawer drawer,
    final Calculator calculator,
    final Sizer sizer
  ) {
    this.width = width;
    this.height = 2 * width;
    this.drawer = drawer;
    this.calculator = calculator;
    this.sizer = sizer;
  }

  public void draw() {
    drawer.drawRectangle(width, height);
  }

  public float calculateArea() {
    return calculator.calcRectArea(width, height);
  }

  public float calculatePerimeter() {
    return calculator.calcRectPerimeter(width, height);
  }

  public void increaseWidth(final float percentage) {
    width = sizer.increase(width, percentage);
    height = 2 * width;
  }

  public void increaseHeight(final float percentage) {
    height = sizer.increase(height, percentage);
    width = height / 2;
  }
}
```

## Static Code Analysis Principle

> ***Let the computer find bugs and issues in the code for you.***

Static code analysis tools find bugs and design-related issues on your behalf. Use multiple static code analysis tools to get the full benefit. Different tools might detect
different issues. Using static code analysis tools frees people's time in code reviews to focus on things that automation cannot tackle.

Below is a list of some common static code analysis tools for different languages:

- Java
    - Jetbrains IntelliJ IDEA IDE inspections
    - SonarLint
    - SonarQube/SonarCloud
- C++
    - Jetbrains CLion IDE inspections
    - Clang-Tidy
    - MISRA C++ 2008 guidelines
    - CppCheck
    - SonarLint
    - SonarQube/SonarCloud
- TypeScript
    - Jetbrains WebStorm IDE inspections
    - ESLint (+ various plugins, like TypeScript plugin)
    - SonarLint
    - SonarQube/SonarCloud

Infrastructure and deployment code should be treated the same way as source code. Remember to run static code analysis
tools on your infrastructure and deployment code, too. Several tools are available for analyzing infrastructure and deployment code, like _Checkcov_, which can be used for analyzing Terraform, Kubernetes, and Helm code. Helm tool contains a linting command
to analyze Helm chart files, and _Hadolint_ is a tool for analyzing _Dockerfiles_ statically.

### Common Static Code Analysis Issues

| Issue                                                                                        | Description/Solution                                                                                                                                                                                                                                |
|----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Chain of instance of checks                                                                  | This issue indicates a chain of conditionals in favor of object-oriented design. Use the _replace conditionals with polymorphism_ refactoring technique to solve this issue.                                                                        |
| Feature envy                                                                                 | Use the _don't ask, tell principle_ from the previous chapter to solve this issue.                                                                                                                                                                  |
| Use of concrete classes                                                                      | Use the _program against interfaces_ principle from the previous chapter to solve this issue.                                                                                                                                                       |
| Assignment to a function argument                                                            | Don't modify function arguments but introduce a new variable. You can avoid this issue in Java by declaring function parameters as _final_.                                                                                                         |
 | Commented-out code                                                                           | Remove the commented-out code. If you need that piece of code in the future, it is available in the version control system forever.                                                                                                                 |
| Const correctness                                                                            | Make variables and parameters const or final whenever possible to achieve immutability and avoid accidental modifications                                                                                                                           |
| Nested switch statement                                                                      | Use switch statements mainly only in factories. Do not nest them.                                                                                                                                                                                   |
 | Nested conditional expression                                                                | Conditional expression (?:) should not be nested because it greatly hinders the code readability.                                                                                                                                                   |
 | Overly complex boolean expression                                                            | Split the boolean expression into parts and introduce constants to store the parts and the final expression                                                                                                                                         |
 | Expression can be simplified                                                                 | This can be refactored automatically by the IDE.                                                                                                                                                                                                    |
 | Switch statement without default branch                                                      | Always introduce a default branch and throw an exception from there. Otherwise, when you are using a switch statement with an enum, you might encounter strange problems after adding a new enum value that is not handled by the switch statement. |
| Law of Demeter                                                                               | The object knows too much. It is coupled to the dependencies of another object, which creates additional coupling and makes code harder to change.                                                                                                  |
 | Reuse of local variable                                                                      | Instead of reusing a variable for a different purpose, introduce a new variable. That new variable can be named appropriately to describe its purpose.                                                                                              |
| Scope of variable is too broad                                                               | Introduce a variable only just before it is needed.                                                                                                                                                                                                 |
 | Protected field                                                                              | Subclasses can modify the protected state of the superclass without the superclass being able to control that. This is an indication of breaking the encapsulation and should be avoided.                                                           |
 | Breaking the encapsulation: Return of modifiable/mutable field                               | Use the _don't leak modifiable internal state outside an object principle_ from the previous chapter to solve this issue.                                                                                                                           |
 | Breaking the encapsulation: Assignment from a method parameter to a modifiable/mutable field | Use the _don't assign from a method parameter to a modifiable field principle_ from the previous chapter to solve this issue.                                                                                                                       |
 | Non-constant public field                                                                    | Anyone can modify a public field. This breaks the encapsulation and should be avoided.                                                                                                                                                              |
 | Overly broad catch-block                                                                     | This can indicate a wrong design. Don't catch the language's base exception class if you should only catch your application's base error class, for example. Read more about handling exceptions in the next section.                               |

## Error/Exception Handling Principle

Many languages like C++, Java, and JavaScript/TypeScript have an exception-handling mechanism that can
handle errors and exceptional situations. First of all, I want to make a clear distinction between these two words:

> ***An error can happen, and one should be prepared for it. An exception is something that should never happen.***

You define errors in your code and throw them in your functions. For example, if you try to write to
a file, you must be prepared for the error that the disk is full, or if you are reading a file, you must be prepared
for the error that the file does not exist (anymore).

Some errors are recoverable. You can delete files
from the disk to free up some space to write to a file. Or, in case a file is not found, you can give a "file not found" error to the user,
who can then retry the operation using
a different file name, for example.

You usually don't need to define your own exceptions in your application, but the system
throws built-in exceptions in *exceptional situations*, like when a programming error is encountered.
An exception can be thrown, for example, when memory is low, and memory
allocation cannot be performed, or when a programming error results in an array index out of bounds or
a null pointer access. When an exception is thrown, the program cannot continue executing
normally and might need to terminate. This is why many exceptions can be categorized as unrecoverable errors. In some cases,
it is possible to recover from exceptions. Suppose a web service encounters an exception while handling an HTTP request. In that case,
you can terminate the handling of the current request, return an error response to the client, and continue handling further
requests normally. It depends on the software component how it should handle exceptional situations. This is important
to consider when designing a new software component. You should define (and document) how the software component should handle exceptions.
Should it terminate the process or perhaps do something else?

Errors define situations where the execution of a function fails for some reason. Typical examples of errors are
a file not found error, an error in sending an HTTP request to a remote service, or a failure to parse a configuration
file. Suppose a function can throw an error. The function caller can decide how to handle the error depending on the error. With transient errors, like
a failing network request, the function caller can wait a while and call the function again. Or, the function caller
can use a default value. For example, if a function tries to
load a configuration file that does not exist, it can use some default configuration instead. In some cases,
the function caller cannot do anything but leave the error unhandled or catch the error but throw
another error at a higher level of abstraction. Suppose a function tries to load a configuration file, but the loading fails, and no
default configuration exists. In that case, the function cannot do anything but pass the error to its caller. Eventually,
this error bubbles up in the call stack, and the whole process is terminated due to the inability to
load the configuration. This is because the configuration is needed to run the application. Without configuration,
the application cannot do anything but exit.

When defining error classes, define a base error class for your software component. You can name the base error class according to the name of the software component.
For example, for the data exporter
microservice, you can define a `DataExporterError` (or `DataExporterServiceError`) base error class. For *common-utils-lib*,
you can define `CommonUtilsError` (or `CommonUtilsLibError`), and for *sales-item-service*, you can define `SalesItemServiceError`.
The popular Python [requests](https://requests.readthedocs.io/en/latest/) library implements this convention.
It defines a `requests.RequestException,` which is the base class for all other errors the library methods can raise.
Many other Python libraries also define a common base error class.

For each function that can throw an error, define a base error class
at the same abstraction level as the function. That error class should extend the software component's base error class. For example,
if you have a `parse(configStr)` method in the `ConfigParser` class, define a base error class for the function inside the class with the name `ParseError`,
i.e., `ConfigParser.ParseError`. If you have a `readFile` method in the `FileReader` class, define a base error class in the `FileReader` class
with the name `ReadFileError`, i.e., `FileReader.ReadFileError`. If all the methods in a class can throw the same error, it is enough to define
only one error at the class level. For example, if you have a `HttpClient` class where all methods like `get`, `post`, `put` etc., can throw
an error, you can only define a single `Error` error class in the `HttpClient` class. The idea behind defining error classes next to
the methods that can throw them is to make the method signatures clearer and better. By looking above the method definition, you can see
the errors it can throw. This is a bit similar to Java's checked exceptions (which we will discuss a bit
later) where you define thrown exceptions in the `throws` clause.

Below is a Java example of errors defined for the data exporter microservice:

```java
// Base error class for the software component
public class DataExporterError extends RuntimeException {
  public DataExporterError(final Exception error) {
    super(error);
  }
}


public class FileReader {
  // Base error class for the 'readFile' method
  // Extends the base error class of the software component
  public static class ReadFileError extends DataExporterError {
    public ReadFileError(final Exception error) {
      super(error);
    }
  }

  void readFile(final String pathName) {
    // ...
    // throw new ReadFileError(...);
  }
}


public class ConfigParser {
  // Base error class for the 'parse' method
  // Extends the base error class of the software component
  public static class ParseError extends DataExporterError {
      public ParseError(final Exception error) {
        super(error);
      }
    }

  void parse(final String configStr) {
  // ...
  // throw new ParseError(...)
  }
}
```

Following the previous rules makes catching errors in the code easy because you can infer the error class
name from the called method name. In the below example, we can infer the `ReadFileError` error class name
from the `readFile` method name:

```java
try {
  final var fileContents = fileReader.readFile(...);
} catch (final FileReader.ReadFileError error) {
  // Handle error
}
```

You can also catch all user-defined errors using the software component's base error class in the catch
clause. The below two examples have the same effect.

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final FileReader.ReadFileError | ConfigParser.ParseError error) {
  // Handle error situation
}
```

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final DataExporterError error) {
  // Handle error situation
}
```

Don't catch the language's base exception class or some other too-generic exception class because that will catch, in addition
to all user-defined errors, exceptions, like null pointer exceptions, which is probably not what you want. So, do
not catch a too-generic exception class like this:

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final Exception exception) {
  // Do not use! Catches all exceptions
}
```

Also, do not catch the `Throwable` class in Java because it will also catch any fatal errors that are not meant to be caught:

```java
try {
  final var configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final Throwable throwable) {
  // Do not use! Catches everything including
  // all exceptions and fatal errors
}
```

Catch all exceptions only in special places in your code, like in the main function or the main loop, like the loop in a web service
processing HTTP requests or the main loop of a thread. Below is an example of correctly catching the language's base exception class in the main function.
When you catch an unrecoverable exception in the main function, log it and exit the process with an appropriate error code. When you catch an
unrecoverable error in a main loop, log it and continue the loop if possible.

```java
public static void main(final String[] args) {
  // ...

   try {
     application.run(...);
   } catch (final Exception exception) {
     logger.log(exception);
     System.exit(1);
   }
}
```

Using the above-described rules, you can make your code future-proof or forward-compatible so that adding new errors to be thrown from a function
in the future is possible. Let's say that you are using a `fetchConfig` function like this:

```java
try {
  final var config = configFetcher.fetchConfig(url);
} catch(final ConfigFetcher.FetchConfigError error) {
  // Handle error ...
}
```

Your code should still work if a new type of error is raised in the `fetchConfig` function. Let's say that the following new errors
could be thrown from the `fetchConfig` function:

- Malformed URL error
- Server not found error
- Connection timeout error

When classes for these new errors are implemented, they must extend the function's base error class, in this case, the `FetchConfigError` class.
Below are the error classes defined:

```java
public class ConfigFetcher {
  // Base error class for 'fetchConfig' method
  // Extends the base error class of the software component
  public static class FetchConfigError extends DataExporterError {
    public FetchConfigError(final Exception error) {
      super(error);
    }
  }

  // An additional error for 'fetchConfig' method
  // Extends the base error class of the method
  public static class MalformedUrlError extends FetchConfigError {
    public MalformedUrlError(final Exception error) {
      super(error);
    }
  }


  // An additional error for 'fetchConfig' method
  // Extends the base error class of the method
  public static class ServerNotFoundError extends FetchConfigError {
    public ServerNotFoundError(final Exception error) {
      super(error);
    }
  }

  // An additional error for 'fetch_config' method
  // Extends the base error class of the method
  public static class ConnectionTimeoutError extends FetchConfigError {
    public ConnectionTimeoutError(final Exception error) {
      super(error);
    }
  }

  public Config fetchConfig(final String url) {
    // ...
    // throw new MalformedUrlError(...)
    // throw new ServerNotFoundError(...)
    // throw new ConnectionTimeoutError(...)
  }
}
```

You can enhance your code at any time to handle different errors thrown from the `fetch_config` method differently.
For example, you might want to handle a `ConnectionTimeoutError` so that the function will wait a while and then retry the
operation because the error is usually transient:

```java
try {
  final var config = configFetcher.fetchConfig(url);
} catch (final ConfigFetcher.ConnectionTimeoutError error) {
  // Retry after a while
} catch (final ConfigFetcher.MalformedUrlError error) {
  // Inform caller that URL should be checked
} catch (final ConfigFetcher.ServerNotFoundError error) {
  // Inform caller that URL host/port cannot be reached
} catch (final ConfigFetcher.FetchConfigError error) {
  // Handle possible other error situations
  // This will catch any error that could be raised
  // in 'fetchConfig' method now and in the future
}
```

In the above examples, we handled thrown errors correctly, but you can easily forget to handle a thrown error.
This is because nothing in the function signature tells you whether the function can throw an error. The only way to find out
is to check the documentation (if available) or investigate the source code (if available). This is one of the biggest problems
regarding exception handling because you must know and remember that a function can throw an error, and you must remember to catch and handle errors.
You don't always want to handle an error immediately, but still, you must be aware that the error will bubble up in the call stack and should be
dealt with eventually somewhere in the code.

Below is an example extracted from the documentation of the popular Python *requests* library:

```python
import requests

r = requests.get('https://api.github.com/events')
r.json()
# [{'repository': {'open_issues': 0, 'url': 'https://github.com/...
```

Did you know that both `requests.get` and `r.json` can raise an error? Unfortunately, the above documentation extract does not include error handling at all.
If you copy-paste the above code sample directly into your production code, you forget to handle errors.
If you go to the API reference documentation of the *requests* library, you can find the documentation for the `get` method.
That documentation (when writing this book) does not tell that the method can raise an error. The documentation only
speaks about the method parameters, return value, and its type. Scrolling down the documentation page, you will find
a section about exceptions. But what if you don't scroll down? You might think that the method does not raise an
error. The `get` method documentation should be corrected to tell that the method can raise an error and contain a link to the section where
possible errors are described.

The above-described problems can be mitigated, at least on some level, when practicing *test-driven development* (TDD).
TDD will be described in the next chapter, which covers testing-related principles. In TDD, you define the tests before
the implementation, forcing you to think about error scenarios and make tests for them. When you have tests
for error scenarios, leaving those scenarios unhandled in the actual implementation code is impossible.

One great solution to the problem that error handling might be forgotten is to make throwing errors more explicit:

> ***Use a 'try' prefix in a function name if the function can throw an error.***

This is a straightforward rule. If a function can throw an error, name the function so that its name starts with `try`.
This makes it clear to every caller that the function can throw an error, and the caller should be prepared
for that. For the caller of the function, there are three alternatives to deal with a thrown error:

1) Catch the base error class of the called function (or software component) and handle the error, e.g., catch `DataFetcher.FetchDataError` if you are calling a method named `tryFetchData` in a class named `DataFetcher`.
2) Catch the base error class of the called function (or software component) and throw a new error on a higher level of abstraction. You must also name the calling function with a `try` prefix.
3) Don't catch errors. Let them propagate upwards in the call stack. You must also name the calling function with a `try` prefix.

Here is an example of alternative 1:

```java
public class ConfigFetcher {
  public Configuration fetchConfig(final String configUrl) {
    try {
      final var configString = dataFetcher.tryFetchData(configUrl);
      return configParser.tryParse(configString);
    } catch (final DataFetcher.FetchDataError | ConfigParser.ParseError error) {
      // You could also catch DataFetchError and
      // ConfigParseError in different catch clauses
      // if their handling differs
      // You could also catch the base error class DataExporterError
      // of the software component
    }
  }
}
```

Here is an example of alternative 2:

```java
public class ConfigFetcher {
  public static class FetchConfigError extends DataExporterError {
    public FetchConfigError(final Exception error) {
      super(error);
    }
  }

  public Configuration tryFetchConfig(final String configUrl) {
    try {
      final var configString = dataFetcher.tryFetchData(configUrl);
      return configParser.tryParse(configString);
    } catch (final DataFetcher.FetchDataError | ConfigParser.ParseError error) {
      // Error on higher level of abstraction is thrown
      // This function must be named with the 'try' prefix
      // to indicate that it can throw
      throw new FetchConfigError(...);
    }
  }
}
```

Here is an example of alternative 3:

```java
public class ConfigFetcher {
  public Configuration tryFetchConfig(final String configUrl) {
    // No try-except, all raised errors from both try_fetch_data
    // and try_parse method calls propagate
    // to the caller and
    // this function must be named with the 'try' prefix
    // to indicate that it can raise an error
    final var configString = dataFetcher.tryFetchData(configUrl);
    return configParser.tryParse(configString);
  }
}
```

```java
public class DataExporter {
  public void initialize() {
    try {
      final var config = configFetcher.tryFetchConfig(url);
    } catch (final DataExporterError error) {
      // In this case you must catch the base error class of
      // the software component (DataExporterError), because
      // you don't know what errors tryFetchConfig can
      // raise, because no FetchConfigError class
      // has been defined in the ConfigFetcher class
  }
}
```

If we go back to the *requests* library usage example, the error-raising methods `requests.get` and `Response.json`
could be renamed to `requests.try_get` and `Response.try_parse_body_json`. That would make the earlier example look like
the following:

```python
import requests

response = requests.try_get('https://api.github.com/events')
response.try_parse_body_json()
# [{'repository': {'open_issues': 0, 'url': 'https://github.com/...
```

Now, we can see that the two methods can raise an error. It is easier to remember to put them inside a try/except-block:

```python
import requests

try:
    response = requests.try_get('https://api.github.com/events')
    response.try_parse_body_json()
    # [{'repository': {'open_issues': 0, 'url': 'https://github.com/...
except ...
    # ...
```

To make the try-prefix convention even better, a linting rule that enforces the correct naming of error-throwing functions could be developed.
The rule should force the function name to have a *try* prefix if the function throws or propagates errors. A function propagates errors
when it calls an error-raising (try-prefixed) method outside a try-except block.

You can also create a library that has try-prefixed functions that wrap error-throwing functions that don't follow the try-prefix rule:

{title: "JsonParser.js"}
```js
export default class JsonParser {
  static ParseError = class extends Error {
  }

 static tryParse(json, reviver) {
  try {
    return JSON.parse(json, reviver);
  } catch(error) {
    throw new JsonParser.ParseError(error);
  }
}
```

Now, if you use the `JsonParser`'s `tryParse` method, you can easily infer the class name of the possibly raised errors without the
need to consult any documentation.

A web framework usually provides an error-handling mechanism. The framework catches all possible errors and exceptions when
processing a request and maps them to HTTP responses with HTTP status codes indicating a failure. Typically, the default status code is 500 *Internal Server Error*.
When you utilize the web framework's error-handling mechanism,
there is no significant benefit in naming error-raising functions with the try-prefix because it won't be problematic if you forget to
catch an error. So, you can opt out of the try-prefix rule. Many times, this is what you want to do: pass the error to the web framework's error handler. Usually,
you provide your own error handler instead of using the default one, so you get responses in the format you want.
Also, you don't have to declare your error classes inside
the respective class that can throw the errors. If you want, of course, you can still do that.
We will discuss API error handling again in the *API design principles* chapter.

It is usually a good practice to document the error handling mechanism used in the software component's documentation.

The best way to avoid forgetting to handle errors is to practice rigorous *test-driven development* (TDD) described
in the next chapter. Another great way to avoid forgetting to handle errors is to walk through the final code line by line and check
if the particular line can produce an error. If it can produce an error, what kind of error, and are there multiple
errors the line can produce? Let's have an example with the following code (we focus only on possible
errors, not what the function does):

```python
from typing import Any

import requests
from jwt import PyJWKClient, decode

class JwtAuthorizer:
    # ...

    def __try_get_jwt_claims(
            self, auth_header: str | None
        ) -> dict[str, Any]:
            if not self.__jwks_client:
                oidc_config_response = requests.get(self.__oidc_config_url)
                oidc_config = oidc_config_response.json()
                self.__jwks_client = PyJWKClient(oidc_config['jwks_uri'])

            jwt = auth_header.split('Bearer ')[1] if auth_header else ''
            signing_key = self.__jwks_client.get_signing_key_from_jwt(jwt)
            jwt_claims = decode(jwt, signing_key.key, algorithms=['RS256'])
            return jwt_claims
```

The code on the first line cannot produce an error. On the second line, the `requests.get` method can raise an
error on connection failure, for example. Can it produce other errors? It can produce the following errors:

- Malformed URL (`requests.URLRequired`)
- Connection error (`requests.ConnectionError`)
- Connection timeout (`requests.ConnectTimeout`)
- Read timeout (`requests.ReadTimeout`)

It can also produce an error response, e.g., an internal server error.
Our code does not handle that currently, which is why we should add the following line after the `requests.get` method call:
`oidc_config_response.raise_for_status()`. That call will raise an `HttpError` if the response status code is >= 400.
The third line can raise a `JSONDecodeError` if the response is not valid JSON. The fourth line can raise a `KeyError` because it is possible that the key `jwks_uri` does not exist in the response JSON.
The fifth line can raise an `IndexError` because the list returned
by the `split` does not necessarily have an element at index one. Also, the sixth line can raise an error when
the JWKS client cannot connect to the IAM system, or the JWT is invalid. The second last line can raise an `InvalidTokenError` when the JWT is invalid.
In summary, all the lines in the above code can produce at least one kind of error except the first and last lines.

Let's modify the code to implement error handling instead of passing all possible errors and exceptions to the caller:

```python
from typing import Any

import requests
from jwt import PyJWKClient, PyJWKClientError, decode
from jwt.exceptions import InvalidTokenError


class JwtAuthorizer:
    class GetJwtClaimsError(Exception):
        pass

    def __try_get_jwt_claims(
        self, auth_header: str | None
    ) -> dict[str, Any]:
        try:
            if not self.__jwks_client:
                oidc_config_response = requests.get(self.__oidc_config_url)
                oidc_config_response.raise_for_status()
                oidc_config = oidc_config_response.json()
                self.__jwks_client = PyJWKClient(oidc_config['jwks_uri'])

            jwt = auth_header.split('Bearer ')[1] if auth_header else ''
            signing_key = self.__jwks_client.get_signing_key_from_jwt(jwt)
            jwt_claims = decode(jwt, signing_key.key, algorithms=['RS256'])
            return jwt_claims
        except (
            # RequestException is the base error for all errors
            # in the 'requests' library
            requests.RequestException,
            KeyError,
            IndexError,
            PyJWKClientError,
            # Base error when decode() fails on a token
            InvalidTokenError,
        ) as error:
            raise self.GetJwtClaimsError(error)
```

Make yourself a habit of walking through the code of a function line by line once you think it is ready to find out if you have accidentally missed handling some error.

### Handling Checked Exceptions in Java

You can use checked exceptions in Java when defining your software component's errors. Using checked exceptions helps you to remember to handle errors or let them propagate upwards in the call stack.

When using Java's checked exceptions, define the software component's base error class to extend the `Exception` class instead of the `RuntimeException` class. When a function throws a checked exception,
prefixing the function name with the _try_ prefix becomes unnecessary. You can also declare your error classes as top-level classes. You don't need to put them inside the class whose methods can throw them. Below is an example of defining checked exceptions:

```java
public class DataExporterError extends Exception {
  public DataExporterError(final Exception error) {
    super(error);
  }
}

public class DataFetcher {
  public class FetchDataError extends DataExporterError {
    public FetchDataError(final Exception error) {
      super(error);
    }
  }

  public String fetchData(...) throws FetchDataError {
    // ...
  }
}

public class ConfigParser {
  public class ParseError extends DataExporterError {
    public ParseError(final Exception error) {
      super(error);
    }
  }

  public Configuration parse(...) throws ParseError {
    // ...
  }
}

public class DataExporter {
  public class InitializeError extends DataExporterError {
    public InitializeError(final Exception error) {
      super(error);
    }
  }

  public void initialize(...) throws InitializeError {
    try {
      final var configString = dataFetcher.fetchData(configUrl);
      final var config = configParser.parse(configString);

      // ...
    } catch (
      final DataFetcher.FetchDataError | ConfigParser.ParseError error
    ) {
      throw new InitializeError(error);
    }
  }
}
```

Later, it is possible to modify the implementation of the `parse` function to throw other
errors that derive from the `ParseError` class. This kind of change does not require
modifications to other parts of the codebase.

On higher levels of the software component code, you can also use the base error class of the software component in the
`throws` clause to propagate errors upwards in the call stack:

```
public class DataExporter {
  public void initialize(...) throws DataExporterError {
    final var configString = dataFetcher.fetchData(configUrl);
    final var config = configParser.parse(configDataString);

    // ...
  }
}
```

### Returning Errors

As an alternative to throwing errors, it is possible to
communicate erroneous behavior to the function caller using a return value. Using an exception-handling mechanism
provides some advantages over returning errors. When a function can return an error, you must always check
for the error right after the function call. This can cause the code to contain nested if-statements, which hinders code readability.
The exception-handling mechanism allows you to propagate an error
to a higher level in the call stack. You can also execute multiple function calls that can fail inside
a single `try` block and provide a single error handler in the `catch` block. Some languages do not provide an exception-handling mechanism, meaning you must return errors from functions. In
languages like C++, you can optimize mission-critical code by returning error values or indicators instead of throwing exceptions.

#### Returning Failure Indicator

You can return a failure indicator from a failable function when the function does not need to return any additional value.
It is enough to return a failure indicator from the function when there is no need to return any specific error code or message.
This can be because there is only one reason the function can fail, or function callers are not interested in error details.
To return a failure indicator, return a boolean value from the function: _true_ means a successful operation and _false_ indicates a failure:

```cpp
bool performTask(...)
{
  bool taskWasPerformed;

  // Perform the task and set the value of 'taskWasPerformed'

  return taskWasPerformed;
}
```

#### Returning an Optional Value

Suppose a function should return a value, but the function call can fail, and there is precisely one cause
why the function call can fail. In this case,
return an optional value from the function. In the below example, getting a value from the cache can only fail when
no value for a specific key is stored in the cache. We don't need to return any error code or message.

{title: "Cache.java"}
```java
public interface Cache<TKey, TValue> {
  void add(final TKey key, final TValue value);
  Optional<TValue> get(final TKey key);
}
```

In TypeScript, you can return an optional value using a type union:

{title: "Cache.ts"}
```ts
interface MyCache<TKey, TValue> {
  add(key: TKey, value: TValue): void;
  get(key: TKey): TValue | null;
}
```

#### Returning an Error Object

When you need to provide details about an error to a function caller, you can return an error object from the function:

{title: "BackendError.ts"}
```ts
export type BackendError = {
  statusCode: number;
  errorCode: number;
  message: string;
};
```

If a function does not return any value but can produce an error, you can return either an error object or
_null_ in languages that have _null_ defined as a distinct type and the language supports type unions (e.g., TypeScript):

{title: "DataStore.ts"}
```ts
export interface DataStore {
  updateEntity<T extends Entity>(...):
    Promise<BackendError | null>;
}
```

Alternatively, return an optional error. Below is an example in Java:

```java
import lombok.experimental.Value;


@Value
public class BackendError {
  int statusCode;
  int errorCode;
  String message;
}


public interface DataStore {
  <T extends Entity> Optional<BackendError> updateEntity(...);
}
```

Suppose a function needs to return a value or an error. In that case, you can use a 2-tuple (i.e., a pair) type, where
the first value in the tuple is the actual value or _null_ in case of an error and the second value
in the tuple is an error object or _null_ value in case of a successful operation. Below are examples
in TypeScript and Java. In the Java example, you, of course, need to return optionals instead of nulls.

{title: "DataStore.ts"}
```ts
export class DataStore {
  createEntity<T extends Entity>(...):
    Promise<[T, null] | [null, BackendError]>;
}
```

{title: "DataStore.java"}
```java
import org.javatuples.Pair;

public interface DataStore {
  <T extends Entity> Pair<Optional<T>, Optional<BackendError>>
  createEntity(...);
}
```

The above Java code is cumbersome to use, and the type definition looks long.
We should use an `Either` type here, but Java does not have that. Either type contains one of two values, either
a left value or a right value. The function returns the left value when the operation is successful, and the right value
is an error.

{aside}
Source code for the below example is available [here](https://github.com/pksilen/clean-code-principles-code/tree/main/chapter3/either).
{/aside}

The `Either` type can be defined as follows:

{title: "Either.java"}
```
public class Either<L, R> {
  private final Optional<L> maybeLeftValue;
  private final Optional<R> maybeRightValue;

  private Either(
    final Optional<L> maybeLeftValue,
    final Optional<R> maybeRightValue
  ) {
    this.maybeLeftValue = maybeLeftValue;
    this.maybeRightValue = maybeRightValue;
  }

  public static <L, R> Either<L, R> withLeft(
    final L value
  ) {
    return new Either<>(Optional.of(value), Optional.empty());
  }

  public static <L, R> Either<L, R> withRight(
    final R value
  ) {
    return new Either<>(Optional.empty(), Optional.of(value));
  }

  public boolean hasLeftValue() {
    return maybeLeftValue.isPresent();
  }

  public boolean hasRightValue() {
    return maybeRightValue.isPresent();
  }

  public <T> Either<T, R> mapLeft(
    Function<? super L, ? extends T> mapper
  ) {
    return new Either<>(maybeLeftValue.map(mapper),
                        maybeRightValue);
  }

  public <T> Either<L, T> mapRight(
    Function<? super R, ? extends T> mapper)
  {
      return new Either<>(maybeLeftValue,
                          maybeRightValue.map(mapper));
  }

  public <T> T map(
    Function<? super L, ? extends T> leftValueMapper,
    Function<? super R, ? extends T> rightValueMapper)
  {
    return maybeLeftValue.<T>map(leftValueMapper)
      .orElseGet(() ->
        maybeRightValue.map(rightValueMapper).get());
  }

  public void apply(
    Consumer<? super L> leftValueConsumer,
    Consumer<? super R> rightValueConsumer
  ) {
    maybeLeftValue.ifPresent(leftValueConsumer);
    maybeRightValue.ifPresent(rightValueConsumer);
  }
}
```

Below are some examples of how to use the `Either` class:

```java
class Error extends RuntimeException {
}

final Either<Integer, Error> intOrError = Either.withLeft(3);
final Either<Integer, Error> intOrError2 = Either.withRight(new Error());

System.out.println(intOrError.hasLeftValue()); // Prints true
System.out.println(intOrError2.hasRightValue()); // Prints true

// Prints true
System.out.println(
  intOrError.mapLeft(number -> number * 2).hasLeftValue()
);

// Prints 6
System.out.println(
  intOrError.<Integer>map(number -> number * 2, error -> 0)
);

// Prints 0
System.out.println(
  intOrError2.<Integer>map(number -> number * 2, error -> 0)
);
```

Now, we can use the new `Either` type and rewrite the example as follows:

{title: "DataStore.java"}
```java
public interface DataStore {
  <T extends Entity> Either<T, BackendError> createEntity(...);
}
```

#### Adapt to Wanted Error Handling Mechanism

You can adapt to a desired error-handling mechanism by creating an adapter method. For example, if a library has a throwing method,
you can create an adapter method returning an optional value or error object. Below is a `tryCreate`
factory method in a `VInt` class that can throw:

{title: "VInt.ts"}
```ts
class VInt {
  // ...

  private constructor(...) {
    // ...
  }

  // this will throw if invalid 'value' is given
  // that doesn't match the 'validationSpec'
  static tryCreate<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): VInt<VSpec> | never {
    // constructor can throw
    return new VInt(validationSpec, value);
  }

  // ...
}
```

We can create a `VIntFactory` class with an adapter method for the `tryCreate` factory method in the `VInt` class.
The `VIntFactory` class offers a non-throwing `create` method:

{title: "VIntFactory.ts"}
```ts
class VIntFactory {
  static create<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): VInt<VSpec> | null {
    try {
      return VInt.tryCreate(validationSpec, value);
    } catch {
      return null;
    }
  }
}
```

We can also create a method that does not throw but returns either a value or an error:

{title: "VIntFactory.ts"}
```ts
class VIntFactory {
  static createOrError<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): [VInt<VSpec>, null] | [null, Error] {
    try {
      return [VInt.tryCreate(validationSpec, value), null];
    } catch (error) {
      return [null, error as Error];
    }
  }
}
```

We can also introduce a simplified version of the `Either` type for TypeScript:

{title: "Either.ts"}
```
export type Either<L, R> = [L, null] | [null, R];
```

Now, we can rewrite the above example like this:

{title: "VIntFactory.ts"}
```ts
class VIntFactory {
  static createOrError<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): Either<VInt<VSpec>, Error> {
    try {
      return [VInt.tryCreate(validationSpec, value), null];
    } catch (error) {
      return [null, error as Error];
    }
  }
}
```

#### Asynchronous Function Error Handling

Asynchronous functions are functions that usually can fail. They often execute I/O operations like file or
network I/O. For a failable asynchronous operation, you must remember to handle the failure case. For this reason, it is
suggested to name a failable asynchronous operation using the same _try_ prefix used in function names that can throw.
Below are two examples of handling an asynchronous operation failure in JavaScript/TypeScript:

```js
tryMakeHttpRequest(url).then((value) => {
  // success
}, (error) => {
  // Handle error
});
```

```js
tryMakeHttpRequest(url).then((value) => {
  // success
}).error((error) => {
  // Handle error
});
```

As you can see from the above examples, it is easy to forget to add the error handling.
It would be better if there was a `thenOrCatch` method in the `Promise` class that accepted the following kind of callback:

```js
tryMakeHttpRequest(url).thenOrCatch(([value, error]) => {
  // Now it is harder to forget to handle an error
  // Check 'error' before using the 'value'
});
```

You can make asynchronous function calls synchronous. In JavaScript/TypeScript, this can be done
using the `async` and `await` keywords. A failable asynchronous operation made synchronous can throw. Below is the same example as above made synchronous:

```js
async function fetchData() {
  try {
    await tryMakeHttpRequest(url);
  } catch {
    // Handle error
  }
}
```

#### Functional Exception Handling

{aside}
Source code for the below example is available [here](https://github.com/pksilen/clean-code-principles-code/tree/main/chapter3/failable).
{/aside}

The below `Failable<T>` class can be used in functional error handling. A `Failable<T>` object represents either
a value of type `T` or an instance of the `RuntimeException` class.

{title: "Failable.java"}
```java
public class Failable<T> {
  private final Either<T, RuntimeException> valueOrError;

  private Failable(
    final Either<T, RuntimeException> valueOrError
  ) {
    this.valueOrError = valueOrError;
  }

  public static <T> Failable<T> withValue(
    final T value
  ) {
    return new Failable<>(Either.withLeft(value));
  }

  public static <T> Failable<T> withError(
    final RuntimeException error
  ) {
    return new Failable<>(Either.withRight(error));
  }

  public T orThrow(
    final Class<? extends RuntimeException> ErrorClass
  ) {
    return valueOrError.map(
      (value) -> value,
      (error) -> {
          try {
            throw (RuntimeException)ErrorClass
              .getConstructor(String.class)
              .newInstance(error.getMessage());
          } catch (InvocationTargetException |
                   InstantiationException |
                   IllegalAccessException |
                   IllegalArgumentException |
                   NoSuchMethodException exception) {
            throw new RuntimeException(exception);
          }
      });
  }

  public T orElse(final T otherValue) {
    return valueOrError.map(value -> value,
                            error -> otherValue);
  }

  public <U> Failable<U> mapValue(
    final Function<? super T, ? extends U> mapper
  ) {
    return new Failable<>(valueOrError.mapLeft(mapper));
  }

  public Failable<T> mapError(
    final Function<? super RuntimeException,
                   ? extends RuntimeException> mapper
  ) {
    if (valueOrError.hasLeftValue()) {
      final var error =
        new RuntimeException(mapper
          .apply(new RuntimeException(""))
          .getMessage());

      return Failable.withError(error);
    } else {
      return new Failable<>(valueOrError.mapRight(mapper));
    }
  }
}
```

In the below example, the `readConfig` method returns a `Failable<Configuration>`. The `tryInitialize` function either obtains an instance of
`Configuration` or throws an error of type `InitializeError`.

```java
public void tryInitialize() {
  final var configuration = configReader
    .readConfig(...)
    .orThrow(InitializeError.class);
}
```

The benefit of the above functional approach is that it is shorter than an entire try-catch block. The above functional approach is also as understandable as a try-catch block.
Remember that you should write the shortest, most understandable code. When a method returns a failable, you don't have to name the method
with the _try_ prefix because the method does not throw.

You can also use other methods of the `Failable` class. For example, a default value can be returned with the `orElse` method:

```java
public void initialize() {
  final var configuration = configReader
    .readConfig(...)
    .orElse(new DefaultConfiguration());
}
```

You can also transform multiple imperative failable statements into functional failable statements. For example, instead of writing:

```java
public void tryInitialize() {
  try {
    final var configDataStr = dataFetcher.tryFetchData(configUrl);
    final var configuration = configParser.tryParse(configDataStr);
  } catch (final DataExporterError error) {
    throw new InitializeError(error.getMessage());
  }
}
```

You can write:

```java
public void tryInitialize() {
  try {
    final var configuration = dataFetcher
      .fetchData(configUrl)
      .mapValue(configParser::parse)
      .orThrow(InitializeError.class);
}
```

It is error-prone to use failable imperative code together with functional programming constructs.
Let's assume we have the below TypeScript code that reads and parses multiple configuration files to
a single configuration object:


```ts
configFilePathNames
  .reduce((accumulatedConfig, configFilePathName) => {
    const configJson = fs.readFileSync(configFilePathName, 'utf-8');
    const configuration = JSON.parse(configJson);
    return { ...accumulatedConfig, ...configuration };
}, {});
```

In the above example, it is easy to forget to handle errors because the throwability of the `reduce` function
depends on the supplied callback function. We cannot use the try-prefix anywhere in the above example.
What we can do is the following:

```ts
function tryReadConfig(
  accumulatedConfig: Record<string, unknown>,
  configFilePathName: string
) {
  const configJson = fs.readFileSync(configFilePathName, 'utf-8');
  const configuration = JSON.parse(configJson);
  return { ...accumulatedConfig, ...configuration };
}

export function getConfig(
  configFilePathNames: string[]
): Record<string, unknown> {
  try {
    return configFilePathNames.reduce(tryReadConfig, {});
  } catch (error) {
    // ...
  }
}
```

We have now added the try-prefix, but the code could read better.
A better alternative is to use a functional programming construct, `Failable<T>`, to return a failable configuration. The `Failable<T>` class implementation in
TypeScript is not presented here, but it can be implemented similarly
to Java. Below is an example of using the `Failable<T>` class:

```ts
function accumulatedConfigOrError(
  accumulatedConfigOrError: Failable<Record<string, unknown>>,
  configFilePathName: string
): Failable<Record<string, unknown>> {
  try {
    const configJson = fs.readFileSync(configFilePathName, 'utf-8');
    const config = JSON.parse(configJson);

    return accumulatedConfigOrError.mapValue(accumulatedConfig =>
      ({ ...accumulatedConfig, ...config }));
  } catch (error: any) {
    return accumulatedConfigOrError.mapError(accumulatedError =>
      new Error(`${accumulatedError.message}\n${error.message}`)
    );
  }
}

export function getConfig(
  configFilePathNames: string[]
): Failable<Record<string, unknown>> {
  return configFilePathNames.reduce(
    accumulatedConfigOrError,
    Failable.withValue({})
  );
}
```


If we have a *config1.json* file with the following contents:

```json
{
    "foo": 1,
    "bar": 2
}
```

and we have a *config2.json* file with the following contents:

```json
{
    "xyz": 3
}
```

Then, we can run the following code:

```ts
const configFilePathNames = ['config1.json', 'config2.json'];
const maybeConfig = getConfig(configFilePathNames);
console.log(maybeConfig.orThrow(Error));
// Prints {'foo': 1, 'bar': 2, 'xyz': 3}
```

Let's introduce an error (a missing comma after the first property) in the *config1.json* file:

```json
{
    "foo": 1
    "bar": 2
}
```

Let's also try to provide a non-existing configuration file *config3.json*:

```ts
const configFilePathNames = ['config1.json', 'config3.json'];
constmaybeConfig = getConfig(configFilePathNames);
console.log(maybeConfig.orThrow(Error));
// Throws an error with a two-line message saying config1.json content
// cannot be parsed due to invalid JSON and config3.json file cannot
// be read because it does not exists.
```

#### Stream Error Handling

Handling errors for a stream is also something that can be easily forgotten. Streams are usually used for I/O operations that can fail.
You should be prepared to handle errors when using a stream. In JavaScript/TypeScript,
an error handler for a stream can be registered using the stream's `on` method in the following way: `stream.on('error', () => { ... })`.

Below is an example of using a stream:

```js
// ...

const writeStream = fs.createWriteStream(filePathName);

this.writeStream.on('error', (error) => {
   // Handle errors
});

writeStream.write(...);
// More writes...

writeStream.close();
```

How could we improve developer experience with streams so that error handling is not forgotten?
Adding an error handler callback parameter to the stream factory method is one solution. This callback will be called upon an error. If no
error handling is needed, a _null_ value could be given for the callback. This way, a developer creating a stream can't forget to
supply an error handler function.

## Don't Pass or Return Null Principle

This principle is for languages like Java and C++ that don't implement null values as separate types.
TypeScript implements nulls as distinct types when the _strictNullChecks_ configuration parameter is set to true (in tsconfig.json),
and you should always set it to true. So, this principle does not apply to TypeScript.

The null value is the misguided invention of British computer scientist _Tony Hoare_ who coined his invention
of null references as a *billion-dollar mistake*. The reason is quite evident because we all have done it: forgetting to handle a null value. And when we don't handle a null value, we pass it to other functions that never expect to be called with a null value. Eventually, this will lead
to a null value exception thrown somewhere in the code.

When you return a value from a function, never return a null value. You should return an optional value
instead. In the example below, we return an optional value for a key in a map because there can be no value
associated with a particular key in the map.

```java
// BAD!
public class Map<K, V> {
  public V get(final K key) {
    if (...) {
      // ...
    } else {
      return null;
    }
  }
}


// GOOD!
public class Map<K, V> {
  public Optional<V> get(final K key) {
    // ...
  }
}
```

When you pass arguments to a function, never pass a null value. The called function usually never expects
to be called with null arguments. Suppose a function expects an argument that can be missing. In that case, the function can define a
default value for that argument (possible in C++ and JavaScript/TypeScript, but not in Java), or an overloaded
function can be defined where the optional argument is not present. A function can also be defined so that an argument
has an optional type, but you should prefer an optional parameter or an overloaded version of the function.

## Avoid Off-By-One Errors Principle

Off-by-one errors usually result from the fact that collections in programming languages are indexed with
zero-based indexes. Zero-based indexing is unnatural for human beings but excellent for computers. However, programming languages
should be designed with humans in mind. People never speak about getting the zeroth value of an array.
We speak of getting the first value in the array. As the null value was called a
billion-dollar mistake, I would call the zero-based indexing another billion-dollar mistake. Let's hope
that someday we get a programming language with one-based indexing! But then we must unlearn the zero-based indexing habit...and that's another problem.

Below are two examples of programming errors in JavaScript that are easy to make if you are not careful enough:

```js
for (let index = 0; index <= array.length; index++) {
  // ...
}

for (let index = 0; index < array.length - 1; index++) {
  // ...
}
```

In the first example, there should be '&lt;' instead of '&lt;=', and in the latter example, there should
be '&lt;=' instead of '&lt;'. Fortunately, the above mistakes can be avoided using modern programming language
constructs like Java's enhanced for-loop or C++'s range-based for-loop or functional programming.

Below are two examples of avoiding off-by-one errors in Java:

```java
for (final var value : values) {
  // ...
}

values.stream().forEach(value -> ...);
```

Some languages, like JavaScript, offer a nice way to access an array's last element(s). Instead of writing
`array[array.length - 1]`, you can write `array.at(-1)`. Similarly, `array[array.length - 2]` is the same as
`array.at(-2)`. You can think that a negative index is a one-based index starting from the end of an array.

Let's consider the description of JavaScript's `slice` method:

> The slice() method returns a shallow copy of a portion of an array into a new array object
> selected from start index to end index (end not included).

The problem here is the 'end not included' part. Many people, by default, think that if given a range,
it is inclusive, but in the case of the `slice` method, it is inclusive at the beginning and exclusive at the end:
`[start, end[`. This kind of function definition that is against first assumptions can easily cause off-by-one errors.
It would be better if the `slice` method by default works with an inclusive range `[start, end]`.

Additionally, unit tests are your friend when trying to spot off-by-one errors. So remember to write
unit tests for the edge cases, too.

## Be Critical When Googling or Using Generative AI Principle

> ***You should always analyze code taken from the web to ensure it meets the criteria for production code. Don't let the AI be the master, but an apprentice.***

We all have done it, and we have done it hundreds of times: googled for answers.
Usually, you find good resources by googling, but the problem often is that examples
in the Google results are not necessarily production quality. One specific thing missing in them is error
handling. If you copy and paste code from a website, it is possible that errors in that copy-pasted code are not handled
appropriately. You should always analyze the copy-pasted code to see if error handling needs to be added.

When you provide answers for other people, try to make the code as production-like as possible.
In [Stack Overflow](https://stackoverflow.com/), you find the most up-voted answer right below the question. If the answer is missing error handling,
you can comment on that and let the author improve their answer. You can also up-vote an
answer that seems the most production-ready. The most up-voted answers tend to be pretty old. For this reason, it is
useful to scroll down to see if a more modern solution fits your needs better. You can also up-vote that more modern
solution to make it eventually rank higher in the list of answers.

Regarding open-source libraries, the first examples in their documentation can describe only the "happy path" usage scenario,
and error handling is described only in later parts of the documentation.
This can cause problems if you copy-paste code from the "happy path" example and forget to add error handling.
For this reason, open-source library authors should give production-quality examples early in the documentation.

Regarding generative AI, e.g., ChatGPT, I have a couple of experiences. I asked ChatGPT to generate simple Python Django code.
The generated code was about 95% correct, but it did not work. The problem was that ChatGPT forgot to provide code
for generating the database tables (makemigrations, migrate). If you are inexperienced with the Django framework, that
problem might be challenging to solve. In that case, continue the discussion with ChatGPT and ask it to solve the problem for you.

My other experiment with ChatGPT was to generate GraphQL server code using the Python *Ariadne* library.
The ChatGPT-generated code was for an old version of Ariadne and did not work correctly with a newer version of the
Ariadne library. (Notice that the data used to train ChatGPT contains more older than newer data. ChatGPT could not
prioritize the less and newer data over the older and more data.) It also generated some lines of code in the wrong order,
which prevented the GraphQL API from working at all.
It took quite a lot of debugging for such a small program to find out what was wrong:
The executable schema was created before the query resolver. It should have been created only after defining the
resolver.

You should familiarize yourself with the AI-generated code when using ChatGPT or other generative AI tools. Otherwise, you
don't know what your program is doing, and if the AI-generated code contains bug(s), those will be hard to find
because you don't clearly understand what the code is actually doing. Don't let the AI be the master, but an apprentice.

The best way to prevent bugs related to code taken from the web is to practice *test-driven development* (TDD). TDD is better described
in the next chapter. The idea behind TDD is to specify the function first and write unit test cases for different
scenarios: edge/corner cases, error scenarios, and security scenarios. For example, let's say you are new
to Python and google for a code snippet to perform an HTTP request to an API endpoint.
You copy-paste the code into your function. Now, error scenarios are not handled. What you should do is practice TDD and write unit test cases for different scenarios, like, what if the remote server cannot be
contacted or the contact results in timeout, or what if the remote server responds with an error (an HTTP response with
a status code greater than or equal to 400). What if you need to parse the result from the API (e.g., parse JSON), and it fails?
Once you have written a unit test case for all those scenarios, you can be sure that error handling in the function
implementation is not forgotten.

## Make One Change At A Time Principle

> ***Don't try to make multiple distinct changes at the same time.***

If you try to make multiple unrelated changes simultaneously, you are focusing on too many things and are more likely to introduce a bug or bugs. Don't try to implement two distinct features at the same time. Don't try to
make two distinct refactorings at the same time. Don't try to implement a new feature and do refactoring simultaneously.
Try to make a single change as small and isolated as possible. I have violated this principle so many times. I thought,
okay, this is a small change I can make together with this other change. But later, I realized that the changes were not so
small after all and that I had created some bugs. I didn't know which of the many changes caused the bug. That made the bug hunting more difficult than it should have been.
So, resist the urge to make multiple distinct changes simultaneously. Have all changes that need to be made as separate user stories in the team backlog or list small changes to be done in a TODO.MD file so that they are not forgotten.

If you need to implement a new feature, analyze if you should refactor the code first to make the feature implementation
easier. If the refactoring is not necessary for the feature and the feature is important, you can implement the feature first and refactor the code later.
If you gain benefit by refactoring first and the feature is not time-critical, refactor first and only after that, implement the feature.

## Choosing Right 3rd Party Component Principle

When choosing the suitable 3rd party component, you should take the following into account:

- It provides the needed functionality
- If you are looking for an open-source component, check that the license is appropriate, e.g., without a viral effect (GPL)
- Prefer a well-established component over a brand new component because the brand new component may have bugs, and a smaller community can offer you support.
  You shouldn't determine a well-established component solely by its number of GitHub stars. Instead, check the component download statistics from the package manager.
- Prefer a component that has a higher number of contributors because you can have your reported bugs corrected faster and also new features
  implemented faster.
- Ensure that dependencies are up-to-date. It is a red flag if the component has its dependencies updated like several years ago

## Use Appropriate Data Structure Principle

Next, the main built-in data structures with their use cases will be presented.

Use a list when you need an ordered collection or should be able to store the same item multiple times.

To implement lists, JavaScript has arrays, C++ has the `std::vector` class, and Java has the `ArrayList` class.
Java also has a `Vector` class, but it is advised
to use `ArrayList` unless you need synchronization (vectors are synchronized). Lists are mutable
and can contain duplicate elements. Each element can be accessed by its index in a performant way. If you need to add or remove
elements at the beginning of the list, that is not a cheap operation because all existing elements in the list must be
moved by one index to the right or left. Similarly, if you add an element to the end of a list and the allocated space for
the list is full, new space must be allocated, and the list elements must be copied to the newly allocated space.

### Map

> *Use a map when you need quick access to a value by a key.*

To implement maps, you can use a plain object or the `Map` class in JavaScript, `HashMap` in Java, and `std::ordered_map` or `std::unordered_map` in C++.
Accessing a value by its key is always a cheap operation. In Java, you can use an `EnumMap` when the map keys are of an enumerated type.
For a synchronized map in Java, you can use `ConcurrentHashMap`.
You can iterate over a JavaScript object using one of the following methods: `keys()`, `values()`, or `entries()`.
You can iterate over a Java `Map` using one of the following methods: `keySet()`, `values()`, or `entrySet()`.

### Tuple

> *Use a tuple for a fixed size ordered collection.*

In a tuple, each element can be accessed by its index in a performant way. In TypeScript, you don't have tuples separately,
but you can use fixed-size arrays. In C++, you can use `std::pair` and `std::tuple`. In Java, you must use a library like
[javatuples](https://www.javatuples.org/index.html).

### Set

> *Use a set when you don't need an ordered collection, and duplicate elements are not allowed.*

Accessing a set by a value is cheap when the set is implemented as a hash table. On the contrary, if you have a list,
the whole list may need to be gone through to find a specific value. If you have a list and want to remove
duplicates from it, you can convert the list into a set. You can do that with the `HashSet` constructor in Java or the `Set` constructor in JavaScript. The `unordered_set` and `ordered_set` classes provide set functionality in C++.

### String

> *Use a string to store an immutable ordered collection of characters.*

In JavaScript and Java, strings are immutable. In C++, you can mutate a `std::string`. Accessing a character by its index is
always a cheap operation O(1).

### Deque (Double Ended Queue)

> *Use a deque when you need cheap insertion and removal of elements at either or both ends of the collection.*

Adding and removing elements at the ends of a deque are cheap (O(1))
operations because the deque is implemented as a doubly linked list. The drawback of the deque is that randomly
accessing an element at a specific index is slow (O(n)). To implement deques, you can use the `std::deque` class in
C++ and the `ArrayDeque` class in Java.

### Stack (LIFO Queue)

> *A stack can be implemented using a deque.*

You can push an element into the stack with the deque's push-back method and pop an element out of the stack with the deque's pop-back method.
You can also implement a stack using a list, but operations can be slower sometimes, especially if the stack is large.
C++ has a `std::stack` class that, by default, utilizes the `std::deque` class to implement a stack. Java also has a `Stack` class,
which should not be used, but you should use the `ArrayDeque` class to implement a stack in Java.

### Queue (FIFO Queue)

> *A queue can be implemented using a deque.*

You can add an element to a queue with the deque's push-back method and pop an element from the queue with the deque's pop-front method.
You can also implement a queue using a list, but operations can be slower sometimes, especially if the queue is large.
C++ has a `std::queue` class that, by default, utilizes the `std::deque` class to implement a queue. In Java, you can use
`ArrayDeque` or a `LinkedList` to implement a queue. Java also provides concurrent blocking queues, like `ArrayBlockingQueue`, useful for implementing multithreaded applications with one or more producer and consumer threads.

### Priority Queue

> *Use a priority queue to retrieve elements based on their priority.*

In C++, you can use the `std::priority_queue` class. In Java, you can use `PriorityQueue` or `PriorityBlockingQueue`.

## Optimization Principle

Code optimization makes code run faster and/or consume less memory.
Faster code improves the end-user experience, and optimization reduces the need for computing resources (CPU/memory), making operating the software cheaper.

> ***Avoid premature optimization. Premature optimization may hinder crafting a proper object-oriented design for a software component.***

Measure unoptimized performance first. Then, decide if optimization is needed. Implement optimizations individually and
measure the performance after each optimization to determine if the particular optimization matters. You can then utilize
the knowledge you gained in future projects only to make optimizations that boost performance significantly enough.
Sometimes, you can make performance optimization in the early phase of a project if you know that a particular optimization
is needed (e.g., from previous experience), and the optimization can be implemented without negatively affecting the
object-oriented design.

### Optimization Patterns

The following optimization patterns are described in this section:

- Optimize busy loops only pattern
- Remove unnecessary functionality pattern
- Object pool pattern
- Algorithm complexity reduction pattern
- Cache function results pattern
- Buffer file I/O pattern
- Share identical objects, a.k.a flyweight pattern
- Copy memory in chunks pattern (C++)
- Replace virtual methods with non-virtual methods pattern (C++)
- Inline methods pattern (C++)
- Use unique pointer pattern (C++)

#### Optimize Busy Loops Only Pattern

Optimizations should primarily target only the busy loop or loops in a software component. Busy loops are the loops in threads that
execute over and over again, possibly thousands or more iterations in a second. Performance optimization should not target
functionality that executes only once or a couple of times during the software component's lifetime, and running that
functionality does not take a long time. For example, an application can execute configuration reading and parsing
functionality when it starts. This functionality takes a short time to execute. It is
not reasonable to optimize that functionality because it runs only once.
It does not matter if you can read and parse the configuration in 200 or 300 milliseconds, even if there is a 50% difference in performance.

Let's use the data exporter microservice as an example. Our data exporter microservice consists of input, transformer, and output parts.
The input part reads messages from a data source. We cannot affect the message reading part if we use a 3rd party library for that purpose.
Of course, if multiple 3rd party libraries are available, it is possible to craft performance tests and evaluate which library offers the best performance.
If several 3rd party libraries are available for the same functionality, we tend to use the
most popular library or a library we know beforehand. If performance is an issue, we should evaluate different libraries and compare their performances.

The data exporter microservice has the following functionality in its busy loop: decode an input message to an internal message, perform
transformations, and encode an output message. Decoding an input message requires
decoding each field in the message. Let's say there are 10000 messages handled per second, each with 100 fields.
During one second, 100,000 fields must be decoded. This reveals that the optimization of the decoding functionality
is crucial. The same applies to output message encoding. We at Nokia have implemented the decoding and encoding of Avro binary fields ourselves.
We were able to make them faster than what was provided by a 3rd party library.

#### Remove Unnecessary Functionality Pattern

Removing unnecessary functionality is something that will boost performance. Every now and then, you should stop and think critically about your software component:
Is my software component doing only the necessary things considering all circumstances?

Let's consider the data exporter's functionality in a special case. It is currently decoding an input message to an internal message.
This internal message is used when making various transformations to the data. Transformed data is encoded in a desired output format.
The contents of the final output message can be a small subset
of the original input message. This means that only a tiny part of the decoded message is used. In that case, it is unnecessary
to decode all the fields of an input message if, for example, only 10% of the fields are used in the transformations and
output messages. By removing unnecessary decoding, we can improve
the performance of the data exporter microservice.

#### Object Pool Pattern

In garbage-collected languages like Python, the benefit of using an object pool is evident from the
garbage-collection point of view. Objects are created only once in the object pool pattern and then reused.
This will take pressure away from garbage collection. If we didn't use an object pool,
new objects could be created in a busy loop repeatedly, and soon after they were created, they
could be discarded. This would cause many objects to be made available for garbage collection in
a short time. Garbage collection takes processor time, and if the garbage collector has a lot of garbage to collect,
it can slow the application down for an unknown duration at unknown intervals.

#### Algorithm Complexity Reduction Pattern

Choose an algorithm with reduced complexity as measured using the [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation). This usually boosts the performance.
In the below Python example, we are using the find algorithm with a list:

```python
values = [1, 2, 3, 4, 5, ..., 2000]
if 2000 in values:
    print("Value 2000 found")
```

The above algorithm must traverse the list, which makes it slower (O(n)) compared to the find algorithm with a set (O(1)):

```python
values = {1, 2, 3, 4, 5, ..., 2000}
if 2000 in values:
    print("Value 2000 found")
```

The below algorithm (list comprehension) will generate a list of 20,000 values:

```python
values = [value for value in range(20_000)]
```

If we don't need all the 20,000 values in the memory at the same time,
we could use a different algorithm (generator expression) which consumes much less memory because not all the 20,000 values are in the memory:

```python
values = (value for value in range(20_000))
```

The type of the `values` object in the above example is `Generator`, which inherits from `Iterator`. You can use
the `values` anywhere an iterator is expected.

#### Cache Function Results Pattern

You can benefit from caching the function results if you have an expensive pure function that always returns the same result
for the same input without any side effects. In Python, you can cache function results using the `@cache` or `@lru_cache` decorator. Here is an example:

```python
from functools import lru_cache

# Results of 500 most recent calls to the function
# will be cached
@lru_cache(maxsize=500)
def make_expensive_calc(value: int):
    # ...

print(make_expensive_calc(1))
# After the first call,
# the function result for the input value 1
# will be cached

print(make_expensive_calc(1))
# The result of function call is fetched from the cache
```

`@cache` is the same as `@lru_cache(maxsize=None)`, i.e., the cache does not have a maximum size limit.
With relative ease, you can implement a caching decorator in JavaScript/TypeScript.

#### Buffer File I/O Pattern

You can benefit from setting custom buffer sizes if you are reading/writing large files. The below Pyton examples set buffer sizes to 1MB:

```python
with open('data.json', 'r', buffering=1_048_576) as data_file:
    data = data_file.read()

with open('data.json', 'w', buffering=1_048_576) as data_file:
    data_file.write(data)
```

#### Share Identical Objects a.k.a Flyweight Pattern

If your application has many objects with some identical properties, those parts of the
objects with identical properties are wasting memory. You should extract the
common properties to a new class and make the original objects reference a shared object of that
new class. Now, your objects share a single common object, and possibly significantly less
memory is consumed. This design pattern is called the *flyweight pattern* and was described in more detail
in the earlier chapter.

#### Copy Memory in Chunks Pattern (C++)

If you have a contiguous memory chunk, copy it using
`memcpy`. Don't copy memory byte by byte in a for-loop. The implementation of the `memcpy` function is optimized by a C++ compiler to produce machine code that optimally copies various sizes of memory chunks.
Instead of copying a memory chunk byte by byte, it can, for example, copy memory as 64-bit values in a 64-bit operating system.

In the data exporter microservice, there is the possibility that the input message format and output message format
are the same, e.g., Avro binary. We can have a situation where an Avro record field can be copied as
such from an input message to an output message without any transformation. In that case, decoding that record field is unnecessary
functionality, and we can skip that. What we will do instead is copy a chunk of memory. An Avro record field can be relatively large, even 200 bytes consisting of 40 subfields. We can now skip the decoding
and encoding of those 40 subfields. We simply copy 200 bytes from the input message to the output message.

#### Replace Virtual Methods with Non-Virtual Methods Pattern (C++)

If you are using a lot of calls to virtual functions in a busy loop, there will be some overhead
in checking which virtual method to call due to dynamic dispatch. In C++, this is done using virtual tables
(_vtables_) which are used to check which actual method will be called. The additional vtable check can negatively affect performance in busy loops if virtual methods are called frequently. For example, the data exporter microservice's busy can call an Avro binary decoding and encoding function 50000 times a second. We could optimize these calls
by implementing Avro binary decoding functions as non-virtual (if previously declared as virtual functions).
Non-virtual functions don't need to check the _vtable_, so the call to the function is direct.

#### Inline Methods Pattern (C++)

Suppose you have made the optimization of making a virtual method non-virtual. One more optimization could still be made if the method is small: inline the method. Inlining a method means that calls to the method are eliminated, and the code of the method is placed at the sites where the
calls to the method are made. So, the method does not need to be called at all when it has been inlined.
In the data exporter microservice, we made the Avro binary encoding and decoding functions non-virtual, and now we can make them
also inlined to speed up the microservice. However, a C++ compiler can decide whether an inline function is really inlined or
not. We cannot be 100% sure if the function is inlined. It's up to the compiler. When we define a function
as an inline function with the C++'s `inline` keyword, we are just giving a hint to the compiler that the function
should be inlined. Only non-virtual methods can be inlined. Virtual methods cannot be inlined because they require
checking the _vtable_ to decide which method should be called.

#### Use Unique Pointer Pattern (C++)

If you are using shared pointers, they need to keep the reference count to the shared pointer up to date. In a busy loop, if you use a shared pointer, say a hundred thousand times a second, it starts to show
a difference whether you use a shared pointer or a unique pointer (`std::unique_ptr`). A unique pointer has little to no overhead compared to
a raw pointer. For this reason, there is no need to use a raw pointer in modern C++. It would not bring much to the table performance-wise. If you use a raw pointer, you must remember to release the allocated memory associated with the raw pointer by yourself. If you don't need
a pointed object to be shared by multiple other objects, you can optimize your code in busy loops by changing shared pointers
to unique pointers. Unique pointers always have only one owner, and multiple objects cannot share them.